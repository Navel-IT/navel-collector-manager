#!/usr/bin/env perl
# Copyright 2015 Navel-IT
# navel-scheduler is developed by Yoann Le Garff, Nicolas Boquet and Yann Le Bras under GNU GPL v3

#-> BEGIN

#-> initialization

use strict;
use warnings;

use feature 'say';

use subs qw/
    under
    get
    del
    post
    put
    any
/;

use Getopt::Long;
use Pod::Usage;

use Proc::Daemon;

use Cwd;

use Navel::Logger;
use Navel::Scheduler '$VERSION';
use Navel::Definition::WebService::Parser;
use Navel::Utils qw/
    blessed
    :json
/;

#-> defaults

my (
    $log_file_path,
    $log_no_color,
    $disable_web_services,
    $daemonize,
    $validate_configuration,
    $logger,
    $scheduler,
    $web_services_listeners,
    $prefork_server
);

my $log_severity = 'notice';

my $pid_dir = '/var/run/navel-scheduler';

#-> functions

sub ok_ko($$) {
    my ($ok, $ko) = @_;

    for (@{$ok}) {
        $logger->push_in_queue(
            message => $logger->stepped_log($_),
            severity => 'info'
        ) if defined $_;
    }

    for (@{$ko}) {
        $logger->push_in_queue(
            message => $logger->stepped_log($_),
            severity => 'info'
        ) if defined $_;
    }

    {
        ok => $ok,
        ko => $ko
    };
}

sub save_configuration_on_success($) {
    $logger->push_in_queue(
        message => shift() . ': runtime configuration successfully saved.',
        severity => 'notice'
    );
}

sub save_configuration_on_error($) {
    $logger->bad(
        message => 'An error occurred while saving the runtime configuration: ' . shift() . '.',
        severity => 'error'
    );
}

#-> main

my $getopts = Getopt::Long::Parser->new();

$getopts->configure('bundling');

$getopts->getoptions(
    'log-file-path=s' => \$log_file_path,
    'log-severity=s' => \$log_severity,
    'log-no-color' => \$log_no_color,
    'no-web-services' => \$disable_web_services,
    'daemonize' => \$daemonize,
    'validate-configuration' => \$validate_configuration,
    'help' => sub {
        pod2usage(0);
    },
    'version' => sub {
        say $VERSION;

        exit 0;
    }
) || pod2usage(1);

defined (my $general_configuration_file_path = shift @ARGV) or pod2usage(1);

eval {
    $logger = Navel::Logger->new(
        severity => $log_severity,
        file_path => $log_file_path,
        colored => ! $log_no_color
    );
};

pod2usage(1) unless defined $logger;

if ($daemonize && ! $validate_configuration) {
    $logger->push_in_queue(
        message => 'Daemonizing ....',
        severity => 'info'
    )->flush_queue();

    Proc::Daemon->new(
        working_directory => getcwd(),
        pid_file => $pid_dir . '/navel-scheduler.pid',
        dont_close_fh => [
            __PACKAGE__ . '::DATA'
        ]
    )->Init();

    IO::AIO::reinit();
}

$scheduler = eval {
    Navel::Scheduler->new(
        general_configuration_path => $general_configuration_file_path
    )->prepare(
        logger => $logger
    );
};

if ($@) {
    $logger->push_in_queue(
        message => $logger->stepped_log($@),
        severity => 'emerg'
    )->flush_queue();

    exit 1;
}

$web_services_listeners = eval {
    Navel::Definition::WebService::Parser->new()->read(
        file_path => $scheduler->{configuration}->{definition}->{webservices}->{definitions_from_file}
    )->make();
};

if ($@) {
    $logger->push_in_queue(
        message => $logger->stepped_log($@),
        severity => 'crit'
    )->flush_queue() if $validate_configuration || ! $disable_web_services;

    exit 1 if $validate_configuration;
} elsif ($validate_configuration) {
    $logger->push_in_queue(
        message => 'Configuration is valid.',
        severity => 'notice'
    )->flush_queue();

    exit 0;
}

if (blessed($web_services_listeners) eq 'Navel::Definition::WebService::Parser' && ! $disable_web_services && @{$web_services_listeners->{definitions}}) {
    require Mojolicious::Lite;
    Mojolicious::Lite->import();
    require Mojo::Server::Prefork;
    Mojo::Server::Prefork->import();

    app()->mode('production');
    app()->log()->level('fatal');

    under sub {
        my $controller = shift;

        my $userinfo = $controller->req()->url()->to_abs()->userinfo();

        unless (defined $userinfo && $userinfo eq $scheduler->{configuration}->{definition}->{webservices}->{credentials}->{login} . ':' . $scheduler->{configuration}->{definition}->{webservices}->{credentials}->{password}) {
            $controller->res()->headers()->www_authenticate('Basic');

            $controller->render(
                json => ok_ko([], ['Unauthorized: access is denied due to invalid credentials.']),
                status => 401
            );

            return undef;
        }

        $controller->on(
            finish => sub {
                my $controller = shift;

                my $exception = delete $controller->stash()->{exception};

                if (defined $exception) {
                    $logger->push_in_queue(
                        message => $logger->stepped_log(
                            [
                                'An exception has beed raised by Mojolicious for HTTP ' . $controller->req()->method() . ' on ' . $controller->req()->url()->to_string() . ': ',
                                $exception
                            ]
                        ),
                        severity => 'error'
                    );
                }
            }
        );
    };

    get '/scheduler/api' => {
        json => {
            version => $VERSION
        }
    };

    get '/scheduler/api/general' => sub {
        shift->render(
            json => $scheduler->{configuration}->{definition}
        );
    };

    put '/scheduler/api/save_configuration' => sub {
            my (@ok, @ko);

            $scheduler->{core}->{collectors}->write(
                file_path => $scheduler->{configuration}->{definition}->{collectors}->{definitions_from_file},
                async => 1,
                on_success => \&save_configuration_on_success,
                on_error => \&save_configuration_on_error
            );

            $scheduler->{core}->{rabbitmq}->write(
                file_path => $scheduler->{configuration}->{definition}->{rabbitmq}->{definitions_from_file},
                async => 1,
                on_success => \&save_configuration_on_success,
                on_error => \&save_configuration_on_error
            );

            $scheduler->{configuration}->write(
                file_path => $general_configuration_file_path,
                async => 1,
                on_success => \&save_configuration_on_success,
                on_error => \&save_configuration_on_error
            );

            push @ok, 'Saving the runtime configuration ....';

            shift->render(
                json => ok_ko(\@ok, \@ko)
            );
    };

    put '/scheduler/api/general/webservices/credentials' => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $body = eval {
            decode_json($controller->req()->body());
        };

        unless ($@) {
            if (ref $body eq 'HASH') {
                my $scheduler_definition = $scheduler->{configuration}->{definition};

                eval {
                    $scheduler->{configuration}->set_definition(
                        {
                            %{$scheduler_definition},
                            %{
                                {
                                    webservices => {
                                        %{$scheduler_definition->{webservices}},
                                        credentials => {
                                            %{$scheduler_definition->{webservices}->{credentials}},
                                            %{$body}
                                        }
                                    }
                                }
                            }
                        }
                    );
                };

                unless ($@) {
                    push @ok, 'Credentials of webservices changed.';
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'Body need to represent a hashtable.';
            }
        } else {
            push @ko, $@;
        }

        $controller->render(
            json => ok_ko(\@ok, \@ko)
        );
    };

    get '/scheduler/api/jobs' => sub {
        shift->render(
            json => {
                types => $scheduler->{core}->job_types()
            }
        );
    };

    get '/scheduler/api/jobs/(:job_type)' => sub {
        my $controller = shift;

        $controller->render(
            json => $scheduler->{core}->job_names_by_type($controller->param('job_type'))
        );
    };

    get '/scheduler/api/jobs/(:job_type)/(:job_name)' => sub {
        my $controller = shift;

        my $job_full_name = $controller->param('job_type') . '_' . $controller->param('job_name');

        if (exists $scheduler->{core}->{jobs}->{enabled}->{$job_full_name}) {
            $controller->render(
                json => {
                    enabled => $scheduler->{core}->{jobs}->{enabled}->{$job_full_name}
                }
            );
        } else {
            $controller->render(
                json => {}
            );
        }
    };

    put '/scheduler/api/jobs/(:job_type)/(:job_name)/(:job_action)' => [job_action => qr/(enable|disable)/] => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $job_full_name = $controller->param('job_type') . '_' . $controller->param('job_name');

        my $job_action = $controller->param('job_action');

        if (exists $scheduler->{core}->{jobs}->{enabled}->{$job_full_name}) {
            if ($job_action eq 'enable') {
                $scheduler->{core}->{jobs}->{enabled}->{$job_full_name} = 1;

                push @ok, 'Job ' . $job_full_name . " enabled.";
            } elsif ($job_action eq 'disable') {
                $scheduler->{core}->{jobs}->{enabled}->{$job_full_name} = 0;

                push @ok, 'Job ' . $job_full_name . " disabled.";
            }
        } else {
            push @ko, 'Job ' . $job_full_name . " don't exists.";
        }

        $controller->render(
            json => ok_ko(\@ok, \@ko)
        );
    };

    any [qw/GET POST/] => '/scheduler/api/collectors' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        if ($http_method eq 'POST') {
            my (@ok, @ko);

            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $definition = eval {
                        $scheduler->{core}->{collectors}->add_definition(
                            {
                                %{$body}
                            }
                        );
                    };

                    unless ($@) {
                        $scheduler->{core}->register_collector_by_name($definition->{name});

                        push @ok, 'Collector ' . $definition->{name} . ' added and registered.';
                    } else {
                        push @ko, $@;
                    }
                } else {
                    push @ko, 'Body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } else {
            $controller->render(
                json => $scheduler->{core}->{collectors}->name()
            );
        }
    };

    any [qw/GET PUT DELETE/] => '/scheduler/api/collectors/(:collector)' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        my $collector_name = $controller->param('collector');

        if ($http_method eq 'PUT') {
            my (@ok, @ko);

            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $collector_definition = $scheduler->{core}->{collectors}->definition_by_name($collector_name);

                    if (defined $collector_definition) {
                        delete $body->{name};

                        my $errors = $collector_definition->merge($body);

                        unless (@{$errors}) {
                            push @ok, 'Collector ' . $collector_name . ' changed.';
                        } else {
                            push @ko, 'Error(s) occurred while modifying collector ' . $collector_name . ':', $errors;
                        }
                    } else {
                        push @ko, 'Collector ' . $collector_name . " don't exists.";
                    }
                } else {
                    push @ko, 'Body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } elsif ($http_method eq 'DELETE') {
            my (@ok, @ko);

            if ($scheduler->{core}->unregister_job_by_name('collector_' . $collector_name)) {
                eval {
                    $scheduler->{core}->{collectors}->delete_definition($collector_name);
                };

                unless ($@) {
                    push @ok, 'Collector ' . $collector_name . ' unregistered and deleted.';
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'Collector ' . $collector_name . " don't exists.";
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } else {
            $controller->render(
                json => $scheduler->{core}->{collectors}->definition_properties_by_name($collector_name) || {}
            );
        }
    };

    any [qw/GET POST/] => '/scheduler/api/rabbitmq' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        if ($http_method eq 'POST') {
            my (@ok, @ko);

            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $definition = eval {
                        $scheduler->{core}->{rabbitmq}->add_definition($body);
                    };

                    unless ($@) {
                        $scheduler->{core}->init_publisher_by_name($definition->{name})->register_publisher_by_name($definition->{name});

                        push @ok, 'RabbitMQ ' . $definition->{name} . ' added and publisher associated with registered.';

                        $scheduler->{core}->connect_publisher_by_name($definition->{name}) if $definition->{auto_connect};
                    } else {
                        push @ko, $@;
                    }
                } else {
                    push @ko, 'Body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } else {
            $controller->render(
                json => $scheduler->{core}->{rabbitmq}->name()
            );
        }
    };

    any [qw/GET PUT DELETE/] => '/scheduler/api/rabbitmq/(:rabbitmq)' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        my $rabbitmq_name = $controller->param('rabbitmq');

        if ($http_method eq 'PUT') {
            my (@ok, @ko);

            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $publisher = $scheduler->{core}->publisher_by_name($rabbitmq_name);

                    if (defined $publisher) {
                        my $errors = $publisher->{definition}->merge($body);

                        unless (@{$errors}) {
                            push @ok, 'RabbitMQ ' . $publisher->{definition}->{name} . ' changed.';
                        } else {
                            push @ko, 'Error(s) occurred while modifying RabbitMQ ' . $publisher->{definition}->{name}, $errors;
                        }
                    } else {
                        push @ko, 'RabbitMQ ' . $publisher->{definition}->{name} . " and his publisher don't exists.";
                    }
                } else {
                    push @ko, 'Body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } elsif ($http_method eq 'DELETE') {
            my (@ok, @ko);

            if ($scheduler->{core}->unregister_job_by_name('publisher_' . $rabbitmq_name)) {
                push @ok, 'Publisher ' . $rabbitmq_name . ' is unregistered.';

                eval {
                    $scheduler->{core}->delete_publisher_by_name($rabbitmq_name);
                };

                unless ($@) {
                    push @ok, 'RabbitMQ ' . $rabbitmq_name . ' and his publisher deleted.';
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'RabbitMQ ' . $rabbitmq_name . " and his publisher don't exists.";
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } else {
            $controller->render(
                json => $scheduler->{core}->{rabbitmq}->definition_properties_by_name($rabbitmq_name) || {}
            );
        }
    };

    get '/scheduler/api/publishers' => sub {
        shift->render(
            json => [map { $_->{definition}->{name} } @{$scheduler->{core}->{publishers}}]
        );
    };

    get '/scheduler/api/publishers/(:publisher)' => sub {
        my $controller = shift;

        my $publisher_name = $controller->param('publisher');

        my $publisher = $scheduler->{core}->publisher_by_name($publisher_name);

        if (defined $publisher) {
            $controller->render(
                json => {
                    name => $publisher->{definition}->{name},
                    connected => $publisher->is_connected() || 0
                }
            );
        } else {
            $controller->render(
                json => {}
            );
        }
    };

    put '/scheduler/api/publishers/(:publisher)/(:publisher_action)' => [publisher_action => qr/(connect|disconnect)/] => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $publisher_name = $controller->param('publisher');

        my $publisher_action = $controller->param('publisher_action');

        my $publisher = $scheduler->{core}->publisher_by_name($publisher_name);

        if (defined $publisher) {
            if ($publisher_action eq 'connect' || $publisher_action eq 'disconnect') {
                my $method = $publisher_action . '_publisher_by_name';

                push @ok, ucfirst($publisher_action) . 'ing publisher ' . $publisher->{definition}->{name} . ' .... ';

                $scheduler->{core}->$method($publisher->{definition}->{name});
            }
        } else {
            push @ko, 'Publisher ' . $publisher_name . " don't exists.";
        }

        $controller->render(
            json => ok_ko(\@ok, \@ko)
        );
    };

    any [qw/GET POST DELETE/] => '/scheduler/api/publishers/(:publisher)/events' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        my $publisher_name = $controller->param('publisher');

        my $publisher = $scheduler->{core}->publisher_by_name($publisher_name);

        if ($http_method eq 'POST') {
            my (@ok, @ko);

            if (defined $publisher) {
                my $body = eval {
                    decode_json($controller->req()->body());
                };

                unless ($@) {
                    if (ref $body eq 'HASH') {
                        if (defined ($body->{status_method} = delete $body->{status})) {
                            if ($body->{status_method} eq 'ok' || $body->{status_method} eq 'ko_no_source' || $body->{status_method} eq 'ko_exception') {
                                $body->{status_method} = 'set_status_to_' . $body->{status_method};
                            } else {
                                 push @ko, 'Event status is incorrect.';
                            }
                        }

                        unless (@ko) {
                            eval {
                                $publisher->push_in_queue(%{$body});
                            };

                            unless ($@) {
                                push @ok, 'An event has been manually pushed to the queue of publisher ' . $publisher->{definition}->{name} . '.';
                            } else {
                                push @ko, 'An error occurred while manually pushing an event to the queue of publisher ' . $publisher->{definition}->{name} . ': ' . $@ . '.';
                            }
                        }
                    } else {
                        push @ko, 'Body need to represent a hashtable.';
                    }
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'Publisher ' . $publisher_name . " don't exists.";
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } elsif ($http_method eq 'DELETE') {
            my (@ok, @ko);

            if (defined $publisher) {
                $publisher->clear_queue();

                push @ok, 'Queue cleared for publisher ' . $publisher->{definition}->{name} . '.';
            } else {
                push @ko, 'Publisher ' . $publisher_name . " don't exists.";
            }

            $controller->render(
                json => ok_ko(\@ok, \@ko)
            );
        } else {
            $controller->render(
                json => defined $publisher ? [ map { $_->serialized_datas() } @{$publisher->{queue}} ] : []
            );
        }
    };

    get '/scheduler/api/webservices' => {
        json => $web_services_listeners->name()
    };

    get '/scheduler/api/webservices/(:webservice)' => sub {
        my $controller = shift;

        $controller->render(
            json => $web_services_listeners->definition_properties_by_name($controller->param('webservice')) || {}
        );
    };

    $prefork_server = Mojo::Server::Prefork->new(
        app => app(),
        listen => $web_services_listeners->url()
    );

    $logger->push_in_queue(
        message => 'Starting the webservices ....',
        severity => 'notice'
    )->flush_queue();

    eval {
        while (my ($method, $value) = each %{$scheduler->{configuration}->{definition}->{webservices}->{mojo_server}}) {
            $prefork_server->$method($value);
        }

        $prefork_server->silent(1)->start();
    };

    if ($@) {
        $logger->push_in_queue(
            message => $logger->stepped_log($@),
            severity => 'crit'
        )->flush_queue();
    } else {
        $logger->push_in_queue(
            message => 'Webservices started.',
            severity => 'notice'
        )->flush_queue();
    }
}

$logger->push_in_queue(
    message => 'Starting the scheduler ....',
    severity => 'notice'
)->flush_queue();

eval {
    $scheduler->run();
};

if ($@) {
    $logger->bad(
        message => $logger->stepped_log($@),
        severity => 'emerg'
    )->flush_queue();

    exit 1;
}

#-> POD

=pod

=head1 NAME

navel-scheduler - Control and run Navel::Scheduler

=head1 SYNOPSIS

navel-scheduler [<options>] <general-configuration-file-path>

=head1 OPTIONS

=over 4

=item B<--log-file-path=<FILE>>

Log output to FILE.

=item B<--log-severity=<SEVERITY>>

Set severity (syslog format) to SEVERITY.

=item B<--log-no-color>

Disable colored log output.

=item B<--no-web-services>

Disable the web services.

=item B<--daemonize>

Run as a standalone daemon.

=item B<--validate-configuration>

Validate the configuration and exit with the proper code.

=item B<--help>

Print help.

=item B<--version>

Print version.

=back

=head1 DESCRIPTION

navel-scheduler's purpose is to get back datas from collectors at scheduled (Quartz expressions) time then encode and push it through RabbbitMQ to navel-storer.

=head1 AUTHOR

Yoann Le Garff, Nicolas Boquet and Yann Le Bras

=head1 LICENSE

GNU GPL v3

=cut

#-> TPL + END

__DATA__

@@ favicon.ico (base64)
AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
AAAAAAAAAAAADQkAAAAAAADEhwIAAAAAAoddAiWzfAJWwYYCdcKGAnWzfAJWh14CJQAAAALBhgIA
AAAAAAwIAAAAAAAAEgwAAAAAAAD/2AMAjGECHM2OAoDknQLU7aQC9PClAfzwpQH87aMB9OSdAtTN
jQKAimACHP/VAwAAAAAAEAsAAP//EgD/wwIArXcBK+CbAr3wpgL/86cB//KmAP/yqgr/868Z//Ou
Ff/zqAX/8KUA/9+aAr2odAIs/78DAP//FQDIigIAqHQBGOOdArvypwL/8qcB//OsD//2xl7/+d+m
//rlt//65LX/+dmV//W7Pf/ypwP/4ZsBvJ5tAhm+gwIA//8IAN+aAnrxpgL/8qcC//KmAP/2xFj/
+uS0//bJZP/0uTf/9bw///jSf//66MD/9sVa//CmAv/YlQJ7//8IAMuMAhztpALQ8qcC//KoBP/z
rRP/860T//OvGv/ypgD/8qYA//KlAP/yqAb/9cJR//rov//0uDL/6aAA0bh/AhzknQJJ8aYC8/Kn
Av/2w1X/+uKv//S5OP/ypgD/8qcC//KpCP/1wEr/9850//OrDv/4147/+NOB/++lAfPXlAJK66IC
Z/KmAfv1uz7/+ujA//z04//64av/9LMm//KnAv/3zG//+NeN//S2L//ypgD/9sRX//nfpv/xqQn8
4ZsBaO6kAmbypwL7864W//XASv/66L//9bs8//OsEP/yqAb/+NiR//S3Mv/ypQD/8qYA//bDVf/5
4Kf/8akJ/OSdAWfvpQJH8qcC8vKmAP/zrhX/+uS1//W+Rf/ypQD/8qkH//jWjP/0ti//8qYA//Kn
Av/41Yj/+NSG//CmAvLjnQJI76YDGPKnAs7ypwL/8qcB//fOdP/54av/87Ab//KmAP/0tSv/8qsN
//KmAP/1vkT/+ujA//W6OP/upADO3ZkCGfapAQDypwJ08qcC//KnAf/zrRT/+duZ//rir//2w1P/
9LQn//S3MP/3zG//+ujA//bJZv/ypwP/7KMBdf++AwDzqAMA86gDE/KnArXypwL/8qYA//OtE//3
zG3/+uOx//rmuv/65rr/+d6j//XAS//yqAX/8KYBtuegAhPooQIA86gCAPOoAgDzqAMj86gCtfKn
Av/ypwH/8qYA//OsEf/zsiP/87Ef//KqCf/ypgD/8qcCtu+mAiPwpgIA76UCAPOpAwDypwIA86gC
APSpAxPzqAJ18qcCzvKnAvLypwH88qYA/PKnAPLypwHO86gCdfOoAhPxpwIA96oCAN+bAQAAAAAA
0ZICAPOoAgDzqQMA8KUBAPSpAxnzqAJH86gCZvOoAmbzqAJH86gDGfClAQDzqAIA86gDAMyNAQAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAA==

@@ not_found.html.ep
<!DOCTYPE html>
<html lang='en'>
    <head>
        <title>Not found</title>
    </head>
    <body>
        <p style='font-weight:bold'>The page you were requesting could not be found.</p>
    </body>
</html>

@@ exception.html.ep
<!DOCTYPE html>
<html lang='en'>
    % my $error_prefix = 'Unexpected error';
    <head>
        <title><%= $error_prefix %></title>
    <head>
    <body>
        <p style='font-weight:bold; color:red'><%= $error_prefix %>, please report the message below.</p>
        <p style='font-style:italic'><%= $self->stash()->{exception}->message() %></p>
    </body>
</html>
