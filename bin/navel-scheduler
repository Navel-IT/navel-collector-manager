#!/usr/bin/env perl
# Copyright 2015 Navel-IT
# navel-scheduler is developed by Yoann Le Garff, Nicolas Boquet and Yann Le Bras under GNU GPL v3

#-> BEGIN

#-> initialization

use strict;
use warnings;

use feature 'say';

use subs qw/
    plugin
    under
    get
    del
    post
    put
    any
/;

use File::Basename;

use Getopt::Long;
use Pod::Usage;

use Proc::Daemon;

use Cwd;

use Navel::Logger;
use Navel::Scheduler '$VERSION';
use Navel::Definition::WebService::Parser;
use Navel::Utils qw/
    blessed
    :json
/;

#-> defaults

my (
    $log_file_path,
    $log_no_color,
    $daemonize,
    $validate_configuration,
    $disable_web_services,
    $logger,
    $scheduler,
    $web_services_listeners,
    $prefork_server
);

my $log_severity = 'notice';

my $log_datetime_format = '%s';

my $pid_file = '/var/run/navel-scheduler/' . basename(__FILE__) . '.pid';

#-> functions

sub save_configuration_on_success($) {
    $logger->push_in_queue(
        message => shift() . ': runtime configuration successfully saved.',
        severity => 'notice'
    );
}

sub save_configuration_on_error($) {
    $logger->push_in_queue(
        message => 'an error occurred while saving the runtime configuration: ' . shift() . '.',
        severity => 'error'
    );
}

#-> main

my $getopts = Getopt::Long::Parser->new();

$getopts->configure('bundling');

$getopts->getoptions(
    'log-file-path=s' => \$log_file_path,
    'log-severity=s' => \$log_severity,
    'log-no-color' => \$log_no_color,
    'log-datetime-format=s' => \$log_datetime_format,
    'daemonize' => \$daemonize,
    'pid-file=s' => \$pid_file,
    'validate-configuration' => \$validate_configuration,
    'no-web-services' => \$disable_web_services,
    'help' => sub {
        pod2usage(0);
    },
    'version' => sub {
        say $VERSION;

        exit 0;
    }
) || pod2usage(1);

defined (my $general_configuration_file_path = shift @ARGV) or pod2usage(1);

eval {
    $logger = Navel::Logger->new(
        severity => $log_severity,
        file_path => $log_file_path,
        colored => ! $log_no_color,
        datetime_format => $log_datetime_format
    );
};

pod2usage(1) unless defined $logger;

if ($daemonize && ! $validate_configuration) {
    $logger->push_in_queue(
        message => 'daemonizing ....',
        severity => 'info'
    )->flush_queue();

    eval {
        Proc::Daemon->new(
            working_directory => getcwd(),
            pid_file => $pid_file,
            dont_close_fh => [
                __PACKAGE__ . '::DATA'
            ]
        )->Init();
    };

    if ($@) {
        $logger->push_in_queue(
            message => $logger->stepped_log('error while daemonizing ...',
                [
                    $@
                ]
            ),
            severity => 'emerg'
        )->flush_queue();

        exit 1;
    }

    IO::AIO::reinit();
}

$scheduler = eval {
    Navel::Scheduler->new(
        general_configuration_path => $general_configuration_file_path
    )->prepare(
        logger => $logger
    );
};

if ($@) {
    $logger->push_in_queue(
        message => $logger->stepped_log($@),
        severity => 'emerg'
    )->flush_queue();

    exit 1;
}

$web_services_listeners = eval {
    Navel::Definition::WebService::Parser->new()->read(
        file_path => $scheduler->{configuration}->{definition}->{webservices}->{definitions_from_file}
    )->make();
};

if ($@) {
    $logger->push_in_queue(
        message => $logger->stepped_log($@),
        severity => 'crit'
    )->flush_queue() if $validate_configuration || ! $disable_web_services;

    exit 1 if $validate_configuration;
} elsif ($validate_configuration) {
    $logger->push_in_queue(
        message => 'configuration is valid.',
        severity => 'notice'
    )->flush_queue();

    exit 0;
}

if (blessed($web_services_listeners) eq 'Navel::Definition::WebService::Parser' && ! $disable_web_services && @{$web_services_listeners->{definitions}}) {
    require Mojolicious::Lite;
    Mojolicious::Lite->import();
    require Mojo::Server::Prefork;
    Mojo::Server::Prefork->import();

    app()->mode('production');
    app()->log()->level('fatal');

    plugin 'Navel::Mojolicious::Plugin::Logger', {
        logger => $logger
    };

    under sub {
        my $controller = shift;

        my $userinfo = $controller->req()->url()->to_abs()->userinfo();

        unless (defined $userinfo && $userinfo eq $scheduler->{configuration}->{definition}->{webservices}->{credentials}->{login} . ':' . $scheduler->{configuration}->{definition}->{webservices}->{credentials}->{password}) {
            $controller->res()->headers()->www_authenticate('Basic');

            $controller->render(
                json => $controller->ok_ko(
                    {
                        ok => [],
                        ko => ['unauthorized: access is denied due to invalid credentials.']
                    }
                ),
                status => 401
            );

            return undef;
        }

        $controller->on(
            finish => sub {
                my $controller = shift;

                my $exception = delete $controller->stash()->{exception};

                if (defined $exception) {
                    $logger->push_in_queue(
                        message => $logger->stepped_log(
                            [
                                'an exception has been raised by Mojolicious for HTTP ' . $controller->req()->method() . ' on ' . $controller->req()->url()->to_string() . ': ',
                                $exception
                            ]
                        ),
                        severity => 'error'
                    );
                }
            }
        );
    };

    get '/api/status' => {
        json => {
            version => $VERSION
        }
    };

    get '/api/general' => sub {
        shift->render(
            json => $scheduler->{configuration}->{definition}
        );
    };

    put '/api/save_configuration' => sub {
            my $controller = shift;

            my (@ok, @ko);

            $scheduler->{core}->{collectors}->write(
                file_path => $scheduler->{configuration}->{definition}->{collectors}->{definitions_from_file},
                async => 1,
                on_success => \&save_configuration_on_success,
                on_error => \&save_configuration_on_error
            );

            $scheduler->{core}->{rabbitmq}->write(
                file_path => $scheduler->{configuration}->{definition}->{rabbitmq}->{definitions_from_file},
                async => 1,
                on_success => \&save_configuration_on_success,
                on_error => \&save_configuration_on_error
            );

            $scheduler->{configuration}->write(
                file_path => $general_configuration_file_path,
                async => 1,
                on_success => \&save_configuration_on_success,
                on_error => \&save_configuration_on_error
            );

            push @ok, 'saving the runtime configuration.';

            $controller->render(
                json => $controller->ok_ko(
                    {
                        ok => \@ok,
                        ko => \@ko
                    }
                )
            );
    };

    put '/api/general/webservices/credentials' => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $body = eval {
            decode_json($controller->req()->body());
        };

        unless ($@) {
            if (ref $body eq 'HASH') {
                my $scheduler_definition = $scheduler->{configuration}->{definition};

                eval {
                    $scheduler->{configuration}->set_definition(
                        {
                            %{$scheduler_definition},
                            %{
                                {
                                    webservices => {
                                        %{$scheduler_definition->{webservices}},
                                        credentials => {
                                            %{$scheduler_definition->{webservices}->{credentials}},
                                            %{$body}
                                        }
                                    }
                                }
                            }
                        }
                    );
                };

                unless ($@) {
                    push @ok, 'changing credentials of webservices.';
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'body need to represent a hashtable.';
            }
        } else {
            push @ko, $@;
        }

        $controller->render(
            json => $controller->ok_ko(
                {
                    ok => \@ok,
                    ko => \@ko
                }
            )
        );
    };

    get '/api/jobs' => sub {
        shift->render(
            json => {
                types => [
                    keys %{$scheduler->{core}->{job_types}}
                ]
            }
        );
    };

    get '/api/jobs/(:job_type)' => sub {
        my $controller = shift;

        my $job_type = $controller->param('job_type');

        $controller->render(
            json => $scheduler->{core}->job_type_exists($job_type) ? [
                map {
                    $_->{name}
                } @{$scheduler->{core}->jobs_by_type($job_type)}
            ] : []
        );
    };

    get '/api/jobs/(:job_type)/(:job_name)' => sub {
        my $controller = shift;

        my %job_properties = ();

        my $job_type = $controller->param('job_type');

        if ($scheduler->{core}->job_type_exists($job_type)) {
            my $job = $scheduler->{core}->job_by_type_and_name($job_type, $controller->param('job_name'));

            if (defined $job) {
                $job_properties{$_} = $job->{$_} for qw/
                    enabled
                    singleton
                    running
                /;
            }
        }

        $controller->render(
            json => \%job_properties
        );
    };

    put '/api/jobs/(:job_type)/(:job_name)/(:job_action)' => [job_action => qr/(enable|disable|execute)/] => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $job_type = $controller->param('job_type');

        if ($scheduler->{core}->job_type_exists($job_type)) {
            my $job_name = $controller->param('job_name');

            my $job = $scheduler->{core}->job_by_type_and_name($job_type, $job_name);

            if (defined $job) {
                my $job_action = $controller->param('job_action');

                my $enable_property = 'enabled';

                if ($job_action eq 'enable') {
                    $job->{$enable_property} = 1;

                    push @ok, 'enabling job ' . $job->{name} . '.';
                } elsif ($job_action eq 'disable') {
                    $job->{$enable_property} = 0;

                    push @ok, 'disabling job ' . $job->{name} . '.';
                } elsif ($job_action eq 'execute') {
                    $job->exec();

                    push @ok, 'executing job ' . $job->{name} . '.';
                }
            } else {
                push @ko, 'job ' . $job_name . " don't exists.";
            }
        } else {
            push @ko, 'job ' . $job_type . " don't exists";
        }

        $controller->render(
            json => $controller->ok_ko(
                {
                    ok => \@ok,
                    ko => \@ko
                }
            )
        );
    };

    any [qw/GET POST/] => '/api/collectors' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        if ($http_method eq 'POST') {
            my (@ok, @ko);

            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $collector = eval {
                        $scheduler->{core}->{collectors}->add_definition(
                            {
                                %{$body}
                            }
                        );
                    };

                    unless ($@) {
                        $scheduler->{core}->register_collector_by_name($collector->{name});

                        push @ok, 'adding and registering collector ' . $collector->{name} . '.';
                    } else {
                        push @ko, $@;
                    }
                } else {
                    push @ko, 'body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }

            $controller->render(
                json => $controller->ok_ko(
                    {
                        ok => \@ok,
                        ko => \@ko
                    }
                )
            );
        } else {
            $controller->render(
                json => $scheduler->{core}->{collectors}->name()
            );
        }
    };

    any [qw/GET PUT DELETE/] => '/api/collectors/(:collector)' => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $http_method = $controller->req()->method();

        my $collector_name = $controller->param('collector');

        if ($http_method eq 'PUT') {
            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $collector_definition = $scheduler->{core}->{collectors}->definition_by_name($collector_name);

                    if (defined $collector_definition) {
                        delete $body->{name};

                        my %before_modifications = (
                            singleton => $collector_definition->{singleton},
                            interval => $collector_definition->{scheduling}
                        );

                        my $errors = $collector_definition->merge($body);

                        unless (@{$errors}) {
                            $scheduler->{core}->job_by_type_and_name('collector', $collector_definition->{name})->new(
                                singleton => $collector_definition->{singleton},
                                interval => $collector_definition->{scheduling}
                            ) unless $collector_definition->{singleton} == $before_modifications{singleton} && $collector_definition->{scheduling} == $before_modifications{scheduling};

                            push @ok, 'modifying collector ' . $collector_definition->{name} . '.';
                        } else {
                            push @ko, 'error(s) occurred while modifying collector ' . $collector_definition->{name} . ':', $errors;
                        }
                    } else {
                        push @ko, 'collector ' . $collector_name . " don't exists.";
                    }
                } else {
                    push @ko, 'body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }
        } elsif ($http_method eq 'DELETE') {
            if ($scheduler->{core}->unregister_job_by_type_and_name('collector', $collector_name)) {
                eval {
                    $scheduler->{core}->{collectors}->delete_definition(
                        definition_name => $collector_name
                    );
                };

                unless ($@) {
                    push @ok, 'unregistering and deleting collector ' . $collector_name . '.';
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'collector ' . $collector_name . " don't exists.";
            }
        } else {
            $controller->render(
                json => $scheduler->{core}->{collectors}->definition_properties_by_name($collector_name) || {}
            );

            return undef;
        }

        $controller->render(
            json => $controller->ok_ko(
                {
                    ok => \@ok,
                    ko => \@ko
                }
            )
        );
};

    any [qw/GET POST/] => '/api/rabbitmq' => sub {
        my $controller = shift;

        my $http_method = $controller->req()->method();

        if ($http_method eq 'POST') {
            my (@ok, @ko);

            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $rabbitmq = eval {
                        $scheduler->{core}->{rabbitmq}->add_definition($body);
                    };

                    unless ($@) {
                        $scheduler->{core}->init_publisher_by_name($rabbitmq->{name})->register_publisher_by_name($rabbitmq->{name});

                        push @ok, 'adding rabbitmq ' . $rabbitmq->{name} . ' and registering his publisher.';

                        $scheduler->{core}->connect_publisher_by_name($rabbitmq->{name}) if $rabbitmq->{auto_connect};
                    } else {
                        push @ko, $@;
                    }
                } else {
                    push @ko, 'body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }

            $controller->render(
                json => $controller->ok_ko(
                    {
                        ok => \@ok,
                        ko => \@ko
                    }
                )
            );
        } else {
            $controller->render(
                json => $scheduler->{core}->{rabbitmq}->name()
            );
        }
    };

    any [qw/GET PUT DELETE/] => '/api/rabbitmq/(:rabbitmq)' => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $http_method = $controller->req()->method();

        my $rabbitmq_name = $controller->param('rabbitmq');

        if ($http_method eq 'PUT') {
            my $body = eval {
                decode_json($controller->req()->body());
            };

            unless ($@) {
                if (ref $body eq 'HASH') {
                    my $publisher = $scheduler->{core}->publisher_by_name($rabbitmq_name);

                    if (defined $publisher) {
                        delete $body->{name};

                        my %before_modifications = (
                            connected => $publisher->is_connected() || $publisher->is_connecting(),
                            interval => $publisher->{definition}->{scheduling}
                        );

                        my $errors = $publisher->{definition}->merge($body);

                        unless (@{$errors}) {
                            $scheduler->{core}->disconnect_publisher_by_name($publisher->{definition}->{name}) if $before_modifications{connected};

                            $scheduler->{core}->job_by_type_and_name('publisher', $publisher->{definition}->{name})->new(
                                interval => $publisher->{definition}->{scheduling}
                            ) unless $publisher->{definition}->{scheduling} == $before_modifications{interval};

                            push @ok, 'modifying rabbitmq ' . $publisher->{definition}->{name} . '.';
                        } else {
                            push @ko, 'error(s) occurred while modifying rabbitmq ' . $publisher->{definition}->{name}, $errors;
                        }
                    } else {
                        push @ko, 'rabbitmq ' . $rabbitmq_name . " and his publisher don't exists.";
                    }
                } else {
                    push @ko, 'body need to represent a hashtable.';
                }
            } else {
                push @ko, $@;
            }
        } elsif ($http_method eq 'DELETE') {
            if ($scheduler->{core}->unregister_job_by_type_and_name('publisher', $rabbitmq_name)) {
                push @ok, 'unregistering publisher ' . $rabbitmq_name . '.';

                eval {
                    $scheduler->{core}->delete_publisher_and_definition_associated_by_name($rabbitmq_name);
                };

                unless ($@) {
                    push @ok, 'deleting rabbitmq ' . $rabbitmq_name . ' and his publisher.';
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'rabbitmq ' . $rabbitmq_name . " don't exists.";
            }


        } else {
            $controller->render(
                json => $scheduler->{core}->{rabbitmq}->definition_properties_by_name($rabbitmq_name) || {}
            );

            return undef;
        }

        $controller->render(
            json => $controller->ok_ko(
                {
                    ok => \@ok,
                    ko => \@ko
                }
            )
        );
    };

    get '/api/publishers' => sub {
        shift->render(
            json => [map { $_->{definition}->{name} } @{$scheduler->{core}->{publishers}}]
        );
    };

    get '/api/publishers/(:publisher)' => sub {
        my $controller = shift;

        my $publisher_name = $controller->param('publisher');

        my $publisher = $scheduler->{core}->publisher_by_name($publisher_name);

        $controller->render(
            json => defined $publisher ? {
                name => $publisher->{definition}->{name},
                connected => $publisher->is_connected() || 0
            } : {}
        );
    };

    put '/api/publishers/(:publisher)/(:publisher_action)' => [publisher_action => qr/(connect|disconnect)/] => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $publisher_name = $controller->param('publisher');

        my $publisher_action = $controller->param('publisher_action');

        my $publisher = $scheduler->{core}->publisher_by_name($publisher_name);

        if (defined $publisher) {
            if ($publisher_action eq 'connect' || $publisher_action eq 'disconnect') {
                my $method = $publisher_action . '_publisher_by_name';

                push @ok, $publisher_action . 'ing publisher ' . $publisher->{definition}->{name} . '.';

                $scheduler->{core}->$method($publisher->{definition}->{name});
            }
        } else {
            push @ko, 'publisher ' . $publisher_name . " don't exists.";
        }

        $controller->render(
            json => $controller->ok_ko(
                {
                    ok => \@ok,
                    ko => \@ko
                }
            )
        );
    };

    any [qw/GET POST DELETE/] => '/api/publishers/(:publisher)/events' => sub {
        my $controller = shift;

        my (@ok, @ko);

        my $http_method = $controller->req()->method();

        my $publisher_name = $controller->param('publisher');

        my $publisher = $scheduler->{core}->publisher_by_name($publisher_name);

        if ($http_method eq 'POST') {
            if (defined $publisher) {
                my $body = eval {
                    decode_json($controller->req()->body());
                };

                unless ($@) {
                    if (ref $body eq 'HASH') {
                        if (defined ($body->{status_method} = delete $body->{status})) {
                            if ($body->{status_method} eq 'ok' || $body->{status_method} eq 'ko_no_source' || $body->{status_method} eq 'ko_exception') {
                                $body->{status_method} = 'set_status_to_' . $body->{status_method};
                            } else {
                                 push @ko, 'event status is incorrect.';
                            }
                        }

                        unless (@ko) {
                            eval {
                                $publisher->push_in_queue(%{$body});
                            };

                            unless ($@) {
                                push @ok, 'pushing an event to the queue of publisher ' . $publisher->{definition}->{name} . '.';
                            } else {
                                push @ko, 'an error occurred while manually pushing an event to the queue of publisher ' . $publisher->{definition}->{name} . ': ' . $@ . '.';
                            }
                        }
                    } else {
                        push @ko, 'body need to represent a hashtable.';
                    }
                } else {
                    push @ko, $@;
                }
            } else {
                push @ko, 'publisher ' . $publisher_name . " don't exists.";
            }
        } elsif ($http_method eq 'DELETE') {
            if (defined $publisher) {
                $publisher->clear_queue();

                push @ok, 'clearing queue for publisher ' . $publisher->{definition}->{name} . '.';
            } else {
                push @ko, 'publisher ' . $publisher_name . " don't exists.";
            }
        } else {
            $controller->render(
                json => defined $publisher ? [ map { $_->serialized_datas() } @{$publisher->{queue}} ] : []
            );

            return undef;
        }

        $controller->render(
            json => $controller->ok_ko(
                {
                    ok => \@ok,
                    ko => \@ko
                }
            )
        );
    };

    get '/api/webservices' => {
        json => $web_services_listeners->name()
    };

    get '/api/webservices/(:webservice)' => sub {
        my $controller = shift;

        $controller->render(
            json => $web_services_listeners->definition_properties_by_name($controller->param('webservice')) || {}
        );
    };

    $prefork_server = Mojo::Server::Prefork->new(
        app => app(),
        listen => $web_services_listeners->url()
    );

    $logger->push_in_queue(
        message => 'starting the webservices ....',
        severity => 'notice'
    )->flush_queue();

    eval {
        while (my ($method, $value) = each %{$scheduler->{configuration}->{definition}->{webservices}->{mojo_server}}) {
            $prefork_server->$method($value);
        }

        $prefork_server->silent(1)->start();
    };

    if ($@) {
        $logger->push_in_queue(
            message => $logger->stepped_log($@),
            severity => 'crit'
        )->flush_queue();
    } else {
        $logger->push_in_queue(
            message => 'webservices started.',
            severity => 'notice'
        )->flush_queue();
    }
}

$logger->push_in_queue(
    message => 'starting the scheduler ....',
    severity => 'notice'
)->flush_queue();

eval {
    $scheduler->run();
};

if ($@) {
    $logger->push_in_queue(
        message => $logger->stepped_log($@),
        severity => 'emerg'
    )->flush_queue();

    exit 1;
}

#-> POD

=pod

=head1 NAME

navel-scheduler - Control and run Navel::Scheduler

=head1 SYNOPSIS

navel-scheduler [<options>] <general-configuration-file-path>

=head1 OPTIONS

=over 4

=item B<--log-file-path=<FILE>>

Log output to FILE.

=item B<--log-severity=<SEVERITY>>

Set severity (syslog format) to SEVERITY.

=item B<--log-no-color>

Disable colored log output.

=item B<--log-datetime-format=<FORMAT>>

Display datetime in the given FORMAT.

=item B<--daemonize>

Run as a standalone daemon.

=item B<--pid-file=<FILE>>

Write pid to FILE.

=item B<--validate-configuration>

Validate the configuration and exit with the proper code.

=item B<--no-web-services>

Disable the web services.

=item B<--help>

Print help.

=item B<--version>

Print version.

=back

=head1 DESCRIPTION

navel-scheduler's purpose is to get back datas from collectors at scheduled time then encode and push it through RabbbitMQ to navel-storer.

=head1 AUTHOR

Yoann Le Garff, Nicolas Boquet and Yann Le Bras

=head1 LICENSE

GNU GPL v3

=cut

#-> TPL + END

__DATA__

@@ favicon.ico (base64)
AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
AAAAAAAAAAAADQkAAAAAAADEhwIAAAAAAoddAiWzfAJWwYYCdcKGAnWzfAJWh14CJQAAAALBhgIA
AAAAAAwIAAAAAAAAEgwAAAAAAAD/2AMAjGECHM2OAoDknQLU7aQC9PClAfzwpQH87aMB9OSdAtTN
jQKAimACHP/VAwAAAAAAEAsAAP//EgD/wwIArXcBK+CbAr3wpgL/86cB//KmAP/yqgr/868Z//Ou
Ff/zqAX/8KUA/9+aAr2odAIs/78DAP//FQDIigIAqHQBGOOdArvypwL/8qcB//OsD//2xl7/+d+m
//rlt//65LX/+dmV//W7Pf/ypwP/4ZsBvJ5tAhm+gwIA//8IAN+aAnrxpgL/8qcC//KmAP/2xFj/
+uS0//bJZP/0uTf/9bw///jSf//66MD/9sVa//CmAv/YlQJ7//8IAMuMAhztpALQ8qcC//KoBP/z
rRP/860T//OvGv/ypgD/8qYA//KlAP/yqAb/9cJR//rov//0uDL/6aAA0bh/AhzknQJJ8aYC8/Kn
Av/2w1X/+uKv//S5OP/ypgD/8qcC//KpCP/1wEr/9850//OrDv/4147/+NOB/++lAfPXlAJK66IC
Z/KmAfv1uz7/+ujA//z04//64av/9LMm//KnAv/3zG//+NeN//S2L//ypgD/9sRX//nfpv/xqQn8
4ZsBaO6kAmbypwL7864W//XASv/66L//9bs8//OsEP/yqAb/+NiR//S3Mv/ypQD/8qYA//bDVf/5
4Kf/8akJ/OSdAWfvpQJH8qcC8vKmAP/zrhX/+uS1//W+Rf/ypQD/8qkH//jWjP/0ti//8qYA//Kn
Av/41Yj/+NSG//CmAvLjnQJI76YDGPKnAs7ypwL/8qcB//fOdP/54av/87Ab//KmAP/0tSv/8qsN
//KmAP/1vkT/+ujA//W6OP/upADO3ZkCGfapAQDypwJ08qcC//KnAf/zrRT/+duZ//rir//2w1P/
9LQn//S3MP/3zG//+ujA//bJZv/ypwP/7KMBdf++AwDzqAMA86gDE/KnArXypwL/8qYA//OtE//3
zG3/+uOx//rmuv/65rr/+d6j//XAS//yqAX/8KYBtuegAhPooQIA86gCAPOoAgDzqAMj86gCtfKn
Av/ypwH/8qYA//OsEf/zsiP/87Ef//KqCf/ypgD/8qcCtu+mAiPwpgIA76UCAPOpAwDypwIA86gC
APSpAxPzqAJ18qcCzvKnAvLypwH88qYA/PKnAPLypwHO86gCdfOoAhPxpwIA96oCAN+bAQAAAAAA
0ZICAPOoAgDzqQMA8KUBAPSpAxnzqAJH86gCZvOoAmbzqAJH86gDGfClAQDzqAIA86gDAMyNAQAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAA==

@@ not_found.html.ep
<!DOCTYPE html>
<html lang='en'>
    <head>
        <title>Not found</title>
    </head>
    <body>
        <p style='font-weight:bold'>The page you were requesting could not be found.</p>
    </body>
</html>

@@ exception.html.ep
<!DOCTYPE html>
<html lang='en'>
    % my $error_prefix = 'Unexpected error';
    <head>
        <title><%= $error_prefix %></title>
    <head>
    <body>
        <p style='font-weight:bold; color:red'><%= $error_prefix %>, please report the message below.</p>
        <p style='font-style:italic'><%= $self->stash()->{exception}->message() %></p>
    </body>
</html>

