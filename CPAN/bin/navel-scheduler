#!/usr/bin/env perl
# Copyright 2015 Navel-IT
# Navel Scheduler is developed by Yoann Le Garff, Nicolas Boquet and Yann Le Bras under GNU GPL v3

#-> BEGIN

#-> initialization

use 5.10.1;

use lib '/usr/local/share/navel-scheduler/lib';

use Getopt::Long;

use Pod::Usage;

use Proc::Daemon;

use Cwd;

use Mojolicious::Lite;

use Mojo::Server::Prefork;

use EV;

use Navel::Logger;

use Navel::Scheduler qw/
    $VERSION
/;

use Navel::Definition::WebService::Etc::Parser;

use Navel::Utils qw/
    :all
/;

#-> defaults

my (
    $general_configuration_file_path,
    $log_file_path,
    $log_severity,
    $disable_web_services,
    $daemonize,
    $prefork_server
);

my $pid_dir = '/var/run/navel-scheduler';

#-> functions

sub ok_ko($$$) {
    my ($logger, $ok, $ko) = @_;

    for (@{$ok}) {
        $logger->good($_ . '.', 'notice') if (defined $_);
    }

    for (@{$ko}) {
        $logger->bad($_ . '.', 'notice') if (defined $_);
    }

    {
        ok => $ok,
        ko => $ko
    };
}

#-> main

my $getopts = Getopt::Long::Parser->new();

$getopts->configure('bundling');

$getopts->getoptions(
    'h|help' => sub {
        pod2usage(0);
    },
    'v|version' => sub {
        say $VERSION;

        exit 0;
    },
    'c|general-configuration-file-path=s' => \$general_configuration_file_path,
    'log-file-path=s' => \$log_file_path,
    'log-severity=s' => \$log_severity,
    'no-web-services' => \$disable_web_services,
    'daemonize' => \$daemonize

) || pod2usage(1);

if (defined $general_configuration_file_path) {
    my $logger = Navel::Logger->new(
        'notice',
        $log_severity,
        $log_file_path
    );

    if ($daemonize) {
        $logger->push_in_queue('Daemonizing ...', 'info')->flush_queue(1);

        Proc::Daemon->new(
            working_directory => getcwd(),
            pid_file => $pid_dir . '/navel-scheduler.pid',
            dont_close_fh => [
                __PACKAGE__ . '::DATA'
            ]
        )->Init();

        IO::AIO::reinit(); # IO::AIO loaded by Navel::Scheduler
    }

    my $scheduler = eval {
        Navel::Scheduler->new($general_configuration_file_path);
    };

    unless ($@) {
        unless ($disable_web_services) {
            my $web_services_listeners = eval {
                Navel::Definition::WebService::Etc::Parser->new()->read($scheduler->get_configuration()->get_definition()->{webservices}->{definitions_from_file})->make();
            };

            unless ($@) {
                if (@{$web_services_listeners->get_definitions()}) {
                    app()->mode('production');

                    app()->log()->level('fatal');

                    under sub {
                        my $controller = shift;

                        my $userinfo = $controller->req()->url()->to_abs()->userinfo();

                        unless (defined $userinfo && $userinfo eq $scheduler->get_configuration()->get_definition()->{webservices}->{credentials}->{login} . ':' . $scheduler->get_configuration()->get_definition()->{webservices}->{credentials}->{password}) {
                            $controller->res()->headers()->www_authenticate('Basic');

                            $controller->render(
                                json => ok_ko($logger, [], ['Unauthorized : access is denied due to invalid credentials']),
                                status => 401
                            );

                            return undef;
                        }
                    };

                    get '/scheduler/api' => sub {
                        my $controller = shift;

                        my $action = $controller->req()->query_params()->param('action') || '';

                        if ($action eq 'save_configuration') {
                            my (@ok, @ko);

                            eval {
                                $web_services_listeners->write($scheduler->get_configuration()->get_definition()->{webservices}->{definitions_from_file});

                                $scheduler->get_core()->get_connectors()->write($scheduler->get_configuration()->get_definition()->{connectors}->{definitions_from_file});

                                $scheduler->get_core()->get_rabbitmq()->write($scheduler->get_configuration()->get_definition()->{rabbitmq}->{definitions_from_file});

                                $scheduler->get_configuration()->write($general_configuration_file_path);
                            };

                            unless ($@) {
                                push @ok, 'Runtime configuration saved';
                            } else {
                                push @ko, 'Cannot save the runtime configuration : ' . $@;
                            }

                            return $controller->render(
                                json => ok_ko($logger, \@ok, \@ko)
                            );
                        }

                        $controller->render(
                            json => {
                                version => $VERSION
                            }
                        );
                    };

                    get '/scheduler/api/general' => sub {
                        shift->render(
                            json => $scheduler->get_configuration()->get_definition()
                        );
                    };

                    put '/scheduler/api/general/webservices/credentials' => sub {
                        my $controller = shift;

                        my (@ok, @ko);

                        my $body = eval {
                            decode_json($controller->req()->body());
                        };

                        unless ($@) {
                            if (ref $body eq 'HASH') {
                                my $scheduler_definition = $scheduler->get_configuration()->get_definition();

                                if ($scheduler->get_configuration()->set_definition(
                                    {
                                        %{$scheduler_definition},
                                        %{
                                            {
                                                webservices => {
                                                    %{$scheduler_definition->{webservices}},
                                                    credentials => {
                                                        %{$scheduler_definition->{webservices}->{credentials}},
                                                        %{$body}
                                                    }
                                                }
                                            }
                                        }
                                    }
                                )) {
                                    push @ok, 'Credentials of webservices changed';
                                } else {
                                    push @ko, 'An error occurred while modifying the credentials of webservices';
                                }
                            } else {
                                push @ko, 'Body need to be a hashtable';
                            }
                        } else {
                            push @ko, $@;
                        }

                        $controller->render(
                            json => ok_ko($logger, \@ok, \@ko)
                        );
                    };

                    get '/scheduler/api/cron/jobs' => sub {
                        my %jobs = (
                            publishers => [],
                            connectors => []
                        );

                        for (values %{$scheduler->get_core()->get_cron()->jobs()}) {
                            if ($_->{name} =~ /^(connector|publisher)_(.*)/) {
                                push @{$jobs{$1 . 's'}}, $2;
                            }
                        }

                        shift->render(
                            json => \%jobs
                        );
                    };

                    any [qw/GET POST/] => '/scheduler/api/connectors' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('POST') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $definition = eval {
                                            $scheduler->get_core()->get_connectors()->add_definition(
                                                {
                                                    %{$body},
                                                    %{
                                                        {
                                                            exec_directory_path => $scheduler->get_configuration()->get_definition()->{connectors}->{connectors_exec_directory}
                                                        }
                                                    }
                                                }
                                            );
                                        };

                                        unless ($@) {
                                            $scheduler->get_core()->register_connector($definition->get_name());

                                            push @ok, 'Connector ' . $definition->get_name() . ' added and registered';
                                        } else {
                                            push @ko, $@;
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_connectors()->get_names()
                                );
                            }
                        }
                    };

                    any [qw/GET PUT DEL/] => '/scheduler/api/connectors/(:connector)' => sub {
                        my $controller = shift;

                        my $connector_name = $controller->param('connector');

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $connector_definition = $scheduler->get_core()->get_connectors()->get_by_name($connector_name);

                                        if (defined $connector_definition) {
                                            delete $body->{name};

                                            if ($connector_definition->merge($body)) {
                                                push @ok, 'Connector ' . $connector_name . ' changed';
                                            } else {
                                                push @ko, 'An error occurred while modifying connector ' . $connector_name;
                                            }
                                        } else {
                                            push @ko, 'Connector ' . $connector_name . " don't exists";
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            when ('DEL') {
                                my (@ok, @ko);

                                if ($scheduler->get_core()->unregister_job_by_name('connector_' . $connector_name)) {
                                    eval {
                                        $scheduler->get_core()->get_connectors()->delete_definition($connector_name);
                                    };

                                    unless ($@) {
                                        push @ok, 'Connector ' . $connector_name . ' unregistered and deleted';
                                    } else {
                                        push @ko, $@;
                                    }
                                } else {
                                    push @ko, 'Connector ' . $connector_name . " don't exists";
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_connectors()->get_properties_by_name($connector_name) || {}
                                );
                            }
                        }
                    };

                    any [qw/GET POST/] => '/scheduler/api/rabbitmq' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('POST') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $definition = eval {
                                            $scheduler->get_core()->get_rabbitmq()->add_definition($body);
                                        };

                                        unless ($@) {
                                            $scheduler->get_core()->init_publisher($definition->get_name());

                                            $scheduler->get_core()->register_publisher($definition->get_name());

                                            push @ok, 'RabbitMQ ' . $definition->get_name() . ' added and publisher associated with registered';

                                            if ($definition->get_auto_connect()) {
                                                if (my $error = $scheduler->get_core()->get_publisher_by_definition_name($definition->get_name())->connect()) {
                                                    push @ko, 'Connect publisher ' . $definition->get_name() . ' : ' . $error;
                                                } else {
                                                    push @ok, 'Publisher ' . $definition->get_name() . ' connected';
                                                }
                                            }
                                        } else {
                                            push @ko, $@;
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_rabbitmq()->get_names()
                                );
                            }
                        }
                    };

                    any [qw/GET PUT DEL/] => '/scheduler/api/rabbitmq/(:rabbitmq)' => sub {
                        my $controller = shift;

                        my $rabbitmq_name = $controller->param('rabbitmq');

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $publisher = $scheduler->get_core()->get_publisher_by_definition_name($rabbitmq_name);

                                        if (defined $publisher) {
                                            if (my $error = $publisher->disconnect()) {
                                                push @ko, 'Disconnect publisher ' . $publisher->get_definition()->get_name() . ' : ' . $error;
                                            } else {
                                                push @ok, 'Disconnect publisher ' . $publisher->get_definition()->get_name();

                                                if ($publisher->get_definition()->merge($body)) {
                                                    push @ok, 'RabbitMQ ' . $publisher->get_definition()->get_name() . ' changed';
                                                } else {
                                                    push @ko, 'An error occurred while modifying RabbitMQ ' . $publisher->get_definition()->get_name();
                                                }

                                                if (my $error = $publisher->connect()) {
                                                    push @ko, 'Connect publisher ' . $publisher->get_definition()->get_name() . ' : ' . $error;
                                                } else {
                                                    push @ok, 'Connect publisher ' . $publisher->get_definition()->get_name();
                                                }
                                            }
                                        } else {
                                            push @ko, 'RabbitMQ ' . $publisher->get_definition()->get_name() . " and his publisher don't exists";
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            when ('DEL') {
                                my (@ok, @ko);

                                if ($scheduler->get_core()->unregister_job_by_name('publisher_' . $rabbitmq_name)) {
                                    push @ok, 'Publisher ' . $rabbitmq_name . ' is unregistered';

                                    eval {
                                        $scheduler->get_core()->delete_publisher_by_definition_name($rabbitmq_name);
                                    };

                                    unless ($@) {
                                        push @ok, 'Publisher ' . $rabbitmq_name . ' unregistered, disconnected and deleted';

                                        eval {
                                            $scheduler->get_core()->get_rabbitmq()->delete_definition($rabbitmq_name);
                                        };

                                        unless ($@) {
                                            push @ok, 'RabbitMQ ' . $rabbitmq_name . ' deleted'
                                        } else {
                                            push @ko, $@;
                                        }
                                    } else {
                                        push @ko, $@;
                                    }
                                } else {
                                    push @ko, 'RabbitMQ ' . $rabbitmq_name . " and his publisher don't exists";
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_rabbitmq()->get_properties_by_name($rabbitmq_name) || {}
                                );
                            }
                        }
                    };

                    get '/scheduler/api/publishers' => sub {
                        shift->render(
                            json => [map { $_->get_definition()->get_name() } @{$scheduler->get_core()->get_publishers()}]
                        );
                    };

                    any [qw/GET PUT/] => '/scheduler/api/publishers/(:publisher)' => sub {
                        my $controller = shift;

                        my $publisher_name = $controller->param('publisher');

                        my $publisher = $scheduler->get_core()->get_publisher_by_definition_name($publisher_name);

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                my (@ok, @ko);

                                if (defined $publisher) {
                                    my $body = eval {
                                        decode_json($controller->req()->body());
                                    };

                                    unless ($@) {
                                        eval {
                                            $publisher->push_in_queue($body);
                                        };

                                        unless ($@) {
                                            push @ok, 'Datas manually pushed to the queue of publisher ' . $publisher->get_definition()->get_name();
                                        } else {
                                            push @ko, 'An error occurred while manually pushing datas to the queue of publisher ' . $publisher->get_definition()->get_name() . ' : ' . $@;
                                        }
                                    } else {
                                        push @ko, $@;
                                    }
                                } else {
                                    push @ko, 'Publisher ' . $publisher_name . " don't exists";
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                if (defined $publisher) {
                                    my $action = $controller->req()->query_params()->param('action') || '';

                                    if ($action =~ /^(connect|disconnect)$/) {
                                        my $method = $1;

                                        my $method_generic_message = ucfirst($method) . ' publisher ' . $publisher->get_definition()->get_name();

                                        if (my $error = $publisher->$method()) {
                                            $logger->bad($method_generic_message . ' : ' . $error . '.', 'notice');
                                        } else {
                                            $logger->good($method_generic_message . '.', 'notice');
                                        }
                                    } elsif ($action eq 'clear_queue') {
                                        $logger->push_in_queue('Clear queue for publisher ' . $publisher->get_definition()->get_name() . '.', 'notice');

                                        $publisher->$action();
                                    }

                                    return $controller->render(
                                        json => {
                                            name => $publisher->get_definition()->get_name(),
                                            connected => $publisher->get_net()->is_connected() || 0,
                                            messages_in_queue => scalar @{$publisher->get_queue()}
                                        }
                                    );
                                }

                                $controller->render(
                                    json => {}
                                );
                            }
                        }
                    };

                    get '/scheduler/api/webservices' => {
                        json => $web_services_listeners->get_names()
                    };

                    get '/scheduler/api/webservices/(:webservice)' => sub {
                        my $controller = shift;

                        $controller->render(
                            json => $web_services_listeners->get_properties_by_name($controller->param('webservice')) || {}
                        );
                    };

                    $prefork_server = Mojo::Server::Prefork->new(
                        app => app(),
                        listen => $web_services_listeners->get_urls()
                    );

                    $logger->push_in_queue('Starting the webservices ...', 'notice')->flush_queue(1);

                    eval {
                        while (my ($method, $value) = each %{$scheduler->get_configuration()->get_definition()->{webservices}->{mojo_server}}) {
                            $prefork_server->$method($value);
                        }

                        $prefork_server->silent(1)->start();
                    };

                    if ($@) {
                        $logger->bad($@ . '.', 'err')->flush_queue(1);
                    } else {
                        $logger->good('Webservices started.', 'notice')->flush_queue(1);
                    }
                }
            } else {
                $logger->bad($@ . '.', 'err')->flush_queue(1);
            }

        }

        $logger->push_in_queue('Starting the scheduler ...', 'notice')->flush_queue(1);

        eval {
            $scheduler->run($logger);
        };

        if ($@) {
            $logger->bad($@ . '.', 'crit')->flush_queue();

            exit 1;
        }
    } else {
        $logger->bad($@ . '.', 'crit')->flush_queue();

        exit 1;
    }
} else {
    pod2usage(1);
}

exit 0;

#-> POD

=pod

=head1 NAME

navel-scheduler - Control and run Navel::Scheduler

=head1 SYNOPSIS

navel-scheduler [options]

 Options :
     -h, --help    show help
     -v, --version    show version

     -c, --general-configuration-file-path <F>    load general configuration from <F>

     [--log-file-path] <F>   log informations in file <F>
     [--log-severity] <F>    set severity (syslog format) to <F>

     [--no-web-services]   disable the web services

     [--daemonize]   run as a standalone daemon (only work on Unix-like systems)

=head1 DESCRIPTION

navel-scheduler's purpose is to get back datas from connectors at scheduled (Quartz expressions) time then encode and push it through RabbbitMQ to navel-router.

=head1 AUTHOR

Yoann Le Garff, Nicolas Boquet and Yann Le Bras

=head1 LICENSE

GNU GPL v3

=cut

#-> TPL + END

__DATA__

@@ favicon.ico (base64)
AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
AAAAAAAAAAAADQkAAAAAAADEhwIAAAAAAoddAiWzfAJWwYYCdcKGAnWzfAJWh14CJQAAAALBhgIA
AAAAAAwIAAAAAAAAEgwAAAAAAAD/2AMAjGECHM2OAoDknQLU7aQC9PClAfzwpQH87aMB9OSdAtTN
jQKAimACHP/VAwAAAAAAEAsAAP//EgD/wwIArXcBK+CbAr3wpgL/86cB//KmAP/yqgr/868Z//Ou
Ff/zqAX/8KUA/9+aAr2odAIs/78DAP//FQDIigIAqHQBGOOdArvypwL/8qcB//OsD//2xl7/+d+m
//rlt//65LX/+dmV//W7Pf/ypwP/4ZsBvJ5tAhm+gwIA//8IAN+aAnrxpgL/8qcC//KmAP/2xFj/
+uS0//bJZP/0uTf/9bw///jSf//66MD/9sVa//CmAv/YlQJ7//8IAMuMAhztpALQ8qcC//KoBP/z
rRP/860T//OvGv/ypgD/8qYA//KlAP/yqAb/9cJR//rov//0uDL/6aAA0bh/AhzknQJJ8aYC8/Kn
Av/2w1X/+uKv//S5OP/ypgD/8qcC//KpCP/1wEr/9850//OrDv/4147/+NOB/++lAfPXlAJK66IC
Z/KmAfv1uz7/+ujA//z04//64av/9LMm//KnAv/3zG//+NeN//S2L//ypgD/9sRX//nfpv/xqQn8
4ZsBaO6kAmbypwL7864W//XASv/66L//9bs8//OsEP/yqAb/+NiR//S3Mv/ypQD/8qYA//bDVf/5
4Kf/8akJ/OSdAWfvpQJH8qcC8vKmAP/zrhX/+uS1//W+Rf/ypQD/8qkH//jWjP/0ti//8qYA//Kn
Av/41Yj/+NSG//CmAvLjnQJI76YDGPKnAs7ypwL/8qcB//fOdP/54av/87Ab//KmAP/0tSv/8qsN
//KmAP/1vkT/+ujA//W6OP/upADO3ZkCGfapAQDypwJ08qcC//KnAf/zrRT/+duZ//rir//2w1P/
9LQn//S3MP/3zG//+ujA//bJZv/ypwP/7KMBdf++AwDzqAMA86gDE/KnArXypwL/8qYA//OtE//3
zG3/+uOx//rmuv/65rr/+d6j//XAS//yqAX/8KYBtuegAhPooQIA86gCAPOoAgDzqAMj86gCtfKn
Av/ypwH/8qYA//OsEf/zsiP/87Ef//KqCf/ypgD/8qcCtu+mAiPwpgIA76UCAPOpAwDypwIA86gC
APSpAxPzqAJ18qcCzvKnAvLypwH88qYA/PKnAPLypwHO86gCdfOoAhPxpwIA96oCAN+bAQAAAAAA
0ZICAPOoAgDzqQMA8KUBAPSpAxnzqAJH86gCZvOoAmbzqAJH86gDGfClAQDzqAIA86gDAMyNAQAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAA==

@@ not_found.html.ep
<!DOCTYPE html>
<html>
    % my $error = 'Page not found';
    <head><title><%= $error %></title></head>
    <body><%= $error %></body>
</html>

@@ exception.html.ep
<!DOCTYPE html>
<html>
    % my $error = 'Unexpected error';
    <head><title><%= $error %></title><head>
    <body><%= $error %> : please report bugs !</body>
</html>
