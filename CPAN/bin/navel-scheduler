#!/usr/bin/env perl
# Copyright 2015 Navel-IT
# Navel Scheduler is developed by Yoann Le Garff, Nicolas Boquet and Yann Le Bras under GNU GPL v3

#-> BEGIN

#-> initialization

use 5.10.1;

use lib '/usr/local/share/navel-scheduler/lib';

use String::Util qw/
    hascontent
/;

use Getopt::Long;

use Pod::Usage;

use Proc::Daemon;

use Cwd;

use Mojolicious::Lite;

use Mojo::Server::Prefork;

use EV;

use Navel::Logger;

use Navel::Scheduler qw/
    $VERSION
/;

use Navel::Definition::WebService::Etc::Parser;

use Navel::Utils qw/
    :all
/;

#-> defaults

my (
    $general_configuration_file_path,
    $log_file_path,
    $log_severity,
    $disable_rest,
    $daemonize,
    $prefork_server
);

my $pid_dir = '/var/run';

#-> functions

sub ok_ko($$$) {
    my ($logger, $ok, $ko) = @_;

    for (@{$ok}) {
        $logger->good($_ . '.', 'notice') if (defined $_);
    }

    for (@{$ko}) {
        $logger->bad($_ . '.', 'notice') if (defined $_);
    }

    {
        ok => $ok,
        ko => $ko
    };
}

#-> main

my $getopts = Getopt::Long::Parser->new();

$getopts->configure('bundling');

$getopts->getoptions(
    'h|help' => sub {
        pod2usage(0);
    },
    'v|version' => sub {
        say $VERSION;

        exit 0;
    },
    'c|general-configuration-file-path=s' => \$general_configuration_file_path,
    'log-file-path=s' => \$log_file_path,
    'log-severity=s' => \$log_severity,
    'no-rest' => \$disable_rest,
    'daemonize' => \$daemonize

) || pod2usage(1);

if (defined $general_configuration_file_path) {
    my $logger = Navel::Logger->new(
        'notice',
        $log_file_path,
        $log_severity
    );

    my $scheduler = eval {
        Navel::Scheduler->new($general_configuration_file_path);
    };

    if ($daemonize) {
        $logger->push_to_queue('Daemonizing ...', 'info')->flush_queue(1);

        my $mojo_templates_fh = __PACKAGE__ . '::DATA';

        Proc::Daemon->new(
            working_directory => getcwd(),
            pid_file => $pid_dir . '/navel-scheduler.pid',
            dont_close_fh => $logger->is_filehandler_via_lib() ? [
                $mojo_templates_fh,
                $logger->get_filehandler()
            ] : [
                $mojo_templates_fh
            ]
        )->Init();

        IO::AIO::reinit(); # IO::AIO loaded by Navel::Scheduler
    }

    unless ($@) {
        unless ($disable_rest) {
            my $web_services_listeners = eval {
                Navel::Definition::WebService::Etc::Parser->new()->read($scheduler->get_configuration()->get_definition()->{definitions_path}->{webservices})->make();
            };

            unless ($@) {
                if (@{$web_services_listeners->get_definitions()}) {
                    app()->mode('production');

                    app()->log()->level('fatal');

                    under sub {
                        my $controller = shift;

                        my $userinfo = $controller->req()->url()->to_abs()->userinfo();

                        unless (defined $userinfo && $userinfo eq $scheduler->get_configuration()->get_definition()->{webservices}->{login} . ':' . $scheduler->get_configuration()->get_definition()->{webservices}->{password}) {
                            $controller->res()->headers()->www_authenticate('Basic');

                            $controller->render(
                                json => ok_ko($logger, [], ['Unauthorized : access is denied due to invalid credentials']),
                                status => 401
                            );

                            return undef;
                        }
                    };

                    get '/scheduler/api' => sub {
                        my $controller = shift;

                        my $action = $controller->req()->query_params()->param('action') || '';

                        if ($action eq 'write_configuration') {
                            my (@ok, @ko);

                            eval {
                                $web_services_listeners->write($scheduler->get_configuration()->get_definition()->{definitions_path}->{webservices});

                                $scheduler->get_core()->get_connectors()->write($scheduler->get_configuration()->get_definition()->{definitions_path}->{connectors});

                                $scheduler->get_core()->get_rabbitmq()->write($scheduler->get_configuration()->get_definition()->{definitions_path}->{rabbitmq});

                                $scheduler->get_configuration()->write($general_configuration_file_path);
                            };

                            unless ($@) {
                                push @ok, 'Runtime configuration saved';
                            } else {
                                push @ko, 'Cannot save the runtime configuration : ' . $@;
                            }

                            return $controller->render(
                                json => ok_ko($logger, \@ok, \@ko)
                            );
                        }

                        $controller->render(
                            json => {
                                version => $VERSION
                            }
                        );
                    };

                    get '/scheduler/api/general' => sub {
                        shift->render(
                            json => $scheduler->get_configuration()->get_definition()
                        );
                    };

                    put '/scheduler/api/general/webservices' => sub {
                        my $controller = shift;

                        my (@ok, @ko);

                        my $body = eval {
                            decode_json($controller->req()->body());
                        };

                        unless ($@) {
                            if (ref $body eq 'HASH') {
                                my $scheduler_definition = $scheduler->get_configuration()->get_definition();

                                if ($scheduler->get_configuration()->set_definition(
                                    {
                                        %{$scheduler_definition},
                                        %{
                                            {
                                                webservices => {
                                                    %{$scheduler_definition->{webservices}},
                                                    %{$body}
                                                }
                                            }
                                        }
                                    }
                                )) {
                                    push @ok, 'Credentials of webservices changed';
                                } else {
                                    push @ko, 'An error occurred while modifying the credentials of webservices';
                                }
                            } else {
                                push @ko, 'Body need to be a hashtable';
                            }
                        } else {
                            push @ko, $@;
                        }

                        $controller->render(
                            json => ok_ko($logger, \@ok, \@ko)
                        );
                    };

                    get '/scheduler/api/cron/jobs' => sub {
                        shift->render(
                            json => {
                                jobs_count => scalar keys %{$scheduler->get_core()->get_cron()->jobs()}
                            }
                        );
                    };

                    any [qw/GET POST/] => '/scheduler/api/connectors' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('POST') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $definition = eval {
                                            $scheduler->get_core()->get_connectors()->add_definition(
                                                {
                                                    %{$body},
                                                    %{
                                                        {
                                                            exec_directory_path => $scheduler->get_configuration()->get_definition()->{definitions_path}->{connectors_exec_directory}
                                                        }
                                                    }
                                                }
                                            );
                                        };

                                        unless ($@) {
                                            $scheduler->get_core()->register_connector($definition->get_name());

                                            push @ok, 'Connector ' . $definition->get_name() . ' added and registered';
                                        } else {
                                            push @ko, $@;
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_connectors()->get_names()
                                );
                            }
                        }
                    };

                    any [qw/GET PUT DEL/] => '/scheduler/api/connectors/(:connector)' => sub {
                        my $controller = shift;

                        my $connector_name = $controller->param('connector');

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $connector_definition = $scheduler->get_core()->get_connectors()->get_by_name($connector_name);

                                        if (defined $connector_definition) {
                                            delete $body->{name};

                                            if ($connector_definition->merge($body)) {
                                                push @ok, 'Connector ' . $connector_name . ' changed';
                                            } else {
                                                push @ko, 'An error occurred while modifying connector ' . $connector_name;
                                            }
                                        } else {
                                            push @ko, 'Connector ' . $connector_name . " don't exists";
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            when ('DEL') {
                                my (@ok, @ko);

                                if ($scheduler->get_core()->unregister_job_by_name('connector_' . $connector_name)) {
                                    eval {
                                        $scheduler->get_core()->get_connectors()->delete_definition($connector_name);
                                    };

                                    unless ($@) {
                                        push @ok, 'Connector ' . $connector_name . ' unregistered and deleted';
                                    } else {
                                        push @ko, $@;
                                    }
                                } else {
                                    push @ko, 'Connector ' . $connector_name . " don't exists";
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_connectors()->get_properties_by_name($connector_name) || {}
                                );
                            }
                        }
                    };

                    any [qw/GET POST/] => '/scheduler/api/rabbitmq' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('POST') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $definition = eval {
                                            $scheduler->get_core()->get_rabbitmq()->add_definition($body);
                                        };

                                        unless ($@) {
                                            $scheduler->get_core()->init_publisher($definition->get_name());

                                            $scheduler->get_core()->register_publisher($definition->get_name());

                                            push @ok, 'RabbitMQ ' . $definition->get_name() . ' added and publisher associated with registered';

                                            if ($scheduler->get_configuration()->get_definition()->{rabbitmq}->{auto_connect}) {
                                                if (my $error = $scheduler->get_core()->get_publisher_by_definition_name($definition->get_name())->connect()) {
                                                    push @ko, 'Connect publisher ' . $definition->get_name() . ' : ' . $error;
                                                } else {
                                                    push @ok, 'Publisher ' . $definition->get_name() . ' connected';
                                                }
                                            }
                                        } else {
                                            push @ko, $@;
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_rabbitmq()->get_names()
                                );
                            }
                        }
                    };

                    any [qw/GET PUT DEL/] => '/scheduler/api/rabbitmq/(:rabbitmq)' => sub {
                        my $controller = shift;

                        my $rabbitmq_name = $controller->param('rabbitmq');

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                my (@ok, @ko);

                                my $body = eval {
                                    decode_json($controller->req()->body());
                                };

                                unless ($@) {
                                    if (ref $body eq 'HASH') {
                                        my $publisher = $scheduler->get_core()->get_publisher_by_definition_name($rabbitmq_name);

                                        if (defined $publisher) {
                                            if (my $error = $publisher->disconnect()) {
                                                push @ko, 'Disconnect publisher ' . $rabbitmq_name . ' : ' . $error;
                                            } else {
                                                push @ok, 'Disconnect publisher ' . $rabbitmq_name;

                                                if ($publisher->get_definition()->merge($body)) {
                                                    push @ok, 'RabbitMQ ' . $rabbitmq_name . ' changed';
                                                } else {
                                                    push @ko, 'An error occurred while modifying RabbitMQ ' . $rabbitmq_name;
                                                }

                                                if (my $error = $publisher->connect()) {
                                                    push @ko, 'Connect publisher ' . $rabbitmq_name . ' : ' . $error;
                                                } else {
                                                    push @ok, 'Connect publisher ' . $rabbitmq_name;
                                                }
                                            }
                                        } else {
                                            push @ko, 'RabbitMQ ' . $rabbitmq_name . " and his publisher don't exists";
                                        }
                                    } else {
                                        push @ko, 'Body need to be a hashtable';
                                    }
                                } else {
                                    push @ko, $@;
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            when ('DEL') {
                                my (@ok, @ko);

                                if ($scheduler->get_core()->unregister_job_by_name('publisher_' . $rabbitmq_name)) {
                                    push @ok, 'Publisher ' . $rabbitmq_name . ' is unregistered';

                                    eval {
                                        $scheduler->get_core()->delete_publisher_by_definition_name($rabbitmq_name);
                                    };

                                    unless ($@) {
                                        push @ok, 'Publisher ' . $rabbitmq_name . ' disconnected and deleted';

                                        eval {
                                            $scheduler->get_core()->get_rabbitmq()->delete_definition($rabbitmq_name);
                                        };

                                        unless ($@) {
                                            push @ok, 'RabbitMQ ' . $rabbitmq_name . ' deleted'
                                        } else {
                                            push @ko, $@;
                                        }
                                    } else {
                                        push @ko, $@;
                                    }
                                } else {
                                    push @ko, 'RabbitMQ ' . $rabbitmq_name . " and his publisher don't exists";
                                }

                                $controller->render(
                                    json => ok_ko($logger, \@ok, \@ko)
                                );
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_rabbitmq()->get_properties_by_name($rabbitmq_name) || {}
                                );
                            }
                        }
                    };

                    get '/scheduler/api/publishers' => sub {
                        shift->render(
                            json => [map { $_->get_definition()->get_name() } @{$scheduler->get_core()->get_publishers()}]
                        );
                    };

                    get '/scheduler/api/publishers/(:publisher)' => sub {
                        my $controller = shift;

                        my $publisher = $scheduler->get_core()->get_publisher_by_definition_name($controller->param('publisher'));

                        if (defined $publisher) {
                            my $action = $controller->req()->query_params()->param('action') || '';

                            if ($action =~ /^(connect|disconnect)$/) {
                                my $method = $1;

                                my $method_generic_message = ucfirst($method) . ' publisher ' . $publisher->get_definition()->get_name();

                                if (my $error = $publisher->$method()) {
                                    $logger->bad($method_generic_message . ' : ' . $error . '.', 'notice');
                                } else {
                                    $logger->good($method_generic_message . '.', 'notice');
                                }
                            } elsif ($action eq 'clear_queue') {
                                $logger->push_to_queue('Clear queue for publisher ' . $publisher->get_definition()->get_name() . '.', 'notice');

                                $publisher->$action();
                            }

                            return $controller->render(
                                json => {
                                    connected => $publisher->get_net()->is_connected() || 0,
                                    messages_in_queue => scalar @{$publisher->get_queue()}
                                }
                            );
                        }

                        $controller->render(
                            json => {}
                        );
                    };

                    get '/scheduler/api/webservices' => {
                        json => $web_services_listeners->get_names()
                    };

                    get '/scheduler/api/webservices/(:webservice)' => sub {
                        my $controller = shift;

                        $controller->render(
                            json => $web_services_listeners->get_properties_by_name($controller->param('webservice')) || {}
                        );
                    };

                    $prefork_server = Mojo::Server::Prefork->new(
                        app => app(),
                        listen => $web_services_listeners->get_urls()
                    );

                    $logger->push_to_queue('Starting the webservices ...', 'notice')->flush_queue(1);

                    eval {
                        $prefork_server->silent(1)->start();
                    };

                    if ($@) {
                        $logger->bad($@ . '.', 'err')->flush_queue(1);
                    } else {
                        $logger->good('Webservices started.', 'notice')->flush_queue(1);
                    }

                    # $prefork_server->workers();
                    # $prefork_server->accepts()
                    # $prefork_server->multi_accept();
                }
            } else {
                $logger->bad($@ . '.', 'err')->flush_queue(1);
            }

        }

        $logger->push_to_queue('Starting the scheduler ...', 'notice')->flush_queue(1);

        eval {
            $scheduler->run($logger);
        };

        if ($@) {
            $logger->bad($@ . '.', 'crit')->flush_queue();

            exit 1;
        }
    } else {
        $logger->bad($@ . '.', 'crit')->flush_queue();

        exit 1;
    }
} else {
    pod2usage(1);
}

exit 0;

#-> POD

=pod

=head1 NAME

navel-scheduler - Control and run Navel::Scheduler

=head1 SYNOPSIS

navel-scheduler [options]

 Options :
     -h, --help    show help
     -v, --version    show version

     -c, --general-configuration-file-path <F>    load general configuration from <F>

     [--log-file-path] <F>   log informations in file <F>
     [--log-severity] <F>    set severity (syslog format) to <F>

     [--no-rest]   disable the REST api

     [--daemonize]   run as a standalone daemon (only work on Unix-like systems)

=head1 DESCRIPTION

navel-scheduler's purpose is to get back datas from connectors at scheduled (Quartz expressions) time then encode and push it through RabbbitMQ to navel-router.

=head1 AUTHOR

Yoann Le Garff, Nicolas Boquet and Yann Le Bras

=head1 LICENSE

GNU GPL v3

=cut

#-> TPL + END

__DATA__

@@ favicon.ico (base64)
AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAA
AAAAAAD///8B////Af///wH///8BAw4DAxY1FRUycDBDO4I4ZTuDOGUycDBDFjUVFQMOAwP///8B
////Af///wH///8B////Af///wH///8BFTIUEUCNPYVKpEfjTqxK/U+tS/9PrUv/TqxK/UukR+NA
jT2FFTEUEf///wH///8B////Af///wH///8BMGotI0mgRctPrUv/T61L/0+tS/9PrUv/UK1M/0+t
S/9PrUv/T61L/0ifRcsuZioj////Af///wH///8BIEsfDUqiRstPrEv/T61L/0+tS/+BxH7/v+C+
/9nt2f/U6tT/rtmt/2i4ZP9PrEv/SaBFyxxDGw3///8B////AUecQ31OrUv/T61L/0+tS/+Qy43/
2+3b/5XNk/9xvG3/eMB1/6vXqv/i8eL/gMN9/0+tS/9ElkF/////ATJzMAtNqUnhT61L/0+tS/9R
rk3/Va9R/1+0XP9PrUv/T61L/0+tS/9PrUv/gcR//+Dw4P9jtmD/TKZI4ypjKQ1HnUM3TqxK/0+t
S/94wHX/0enQ/2W3Yv9PrUv/T61L/0+tS/9vu2v/qtep/1GuTf+z27H/pdSj/06sSv9Bjz05TKZI
VU+sS/94wHX/4vHi/+v16//X7Nf/Y7Zg/0+tS/+b0Jn/vN+7/2i4Zf9PrUv/hcWC/8jlx/9PrUv/
R51EV02pSVVPrEv/XLNY/3G9bv/i8eL/Z7hj/1ixVP9PrUv/v+C9/1+0W/9PrUv/T61L/4DDff/M
5sv/T61L/0igRVdNqUkzT6xL/U+tS/9Rrk3/4PDg/3G8bv9PrUv/T61L/7/gvf9ftFv/T61L/0+t
S/+k1KP/r9mu/06sSv1Gm0M1TalKCU6tSt9PrUv/T61L/6LToP/F48T/VK9Q/0+tS/91vnL/VK9Q
/0+tS/9puWb/4fDg/3G9bv9NqknfQ5RACf///wFPrUt1Tq1L/0+tS/9XsFP/yOXI/8Tjw/9yvW//
UK1N/1awUv+Jx4b/3O7c/5zQmv9PrUv/TKdId////wH///8BUKxMB0+tS8VPrUv/T61L/1WwUf+k
1KL/3O7c/+fz5//n8+f/z+jO/4XGg/9PrUv/TqtKxUicRAf///8B////Af///wFQrksZT61LxU+t
S/9PrUv/T61L/1SvUP9itl//XrRb/1CtTP9PrUv/Tq1KxU2qSRn///8B////Af///wH///8B////
AVGtTAdPrkt3T61L30+tS/1PrUv/T61L/0+tS/1PrUvfT61Ld1GtTAf///8B////Af///wH///8B
////Af///wH///8B////AVCuTQlPrkszT61LVU+tS1VPrkszUK5NCf///wH///8B////Af///wH/
//8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA
//8AAP//AAD//w==

@@ not_found.html.ep
<!DOCTYPE html>
<html>
    <head><title>Page not found</title></head>
    <body>Page not found</body>
</html>

@@ exception.html.ep
<!DOCTYPE html>
<html>
    <head><title>Unexpected error</title><head>
    <body>Unexpected error : please report bugs !</body>
</html>