#!/usr/bin/env perl
# Copyright 2015 Navel-IT
# Navel Scheduler is developped by Yoann Le Garff, Nicolas Boquet and Yann Le Bras under GNU GPL v3

#-> BEGIN

#-> initialization

use 5.10.1;

use lib '/usr/local/share/navel-scheduler/lib';

use String::Util qw/
    hascontent
/;

use Getopt::Long qw/
    Configure
    GetOptions
/;

use Proc::Daemon;

use Cwd;

use Mojolicious::Lite;

use Mojo::Server::Prefork;

use Mojo::JSON qw/
    decode_json
/;

use EV;

use Navel::Logger;

use Navel::Scheduler qw/
    $VERSION
/;

use Navel::Definition::WebService::Etc::Parser;

#-> defaults

my (
    $general_configuration_file_path,
    $log_file_path,
    $log_severity,
    $disable_rest,
    $daemonize,
    $prefork_server
);

my $pid_dir = '/var/run';

#-> functions

sub get_help() {
    return <<EOF;

        -h, --help    show help
        -v, --version    show version

        -c, --general-configuration-file-path <F>    load general configuration from <F>

        [--log-file-path] <F>   log informations in file <F>
        [--log-severity] <F>    set severity (syslog format) to <F>

        [--no-rest]   disable the REST api

        [--daemonize]   run as a standalone daemon (only work on Unix-like systems)
EOF
}

#-> main

Configure('bundling');

GetOptions(
    'h|help' => sub {
        say get_help();

        exit 0;
    },
    'v|version' => sub {
        say $VERSION;

        exit 0;
    },
    'c|general-configuration-file-path=s' => \$general_configuration_file_path,
    'log-file-path=s' => \$log_file_path,
    'log-severity=s' => \$log_severity,
    'no-rest' => \$disable_rest,
    'daemonize' => \$daemonize

) || die $!;

if (defined $general_configuration_file_path) {
    my $logger = Navel::Logger->new(
        'notice',
        $log_file_path,
        $log_severity
    );

    my $scheduler = eval {
        Navel::Scheduler->new($general_configuration_file_path);
    };

    unless ($@) {
        unless ($disable_rest) {
            my $web_services_listeners = Navel::Definition::WebService::Etc::Parser->new();

            my $return = $web_services_listeners->load($scheduler->get_configuration()->get_definition()->{definitions_path}->{webservices});

            if ($return->[0]) {
                my $return = $web_services_listeners->make();

                if ($return->[0]) {
                    app()->mode('production');

                    app()->log()->level('fatal');

                    under sub {
                        my $controller = shift;

                        my $userinfo = $controller->req()->url()->to_abs()->userinfo();

                        if (defined $userinfo && $userinfo eq $scheduler->get_configuration()->get_definition()->{webservices}->{login} . ':' . $scheduler->get_configuration()->get_definition()->{webservices}->{password}) {
                            return 1;
                        } else {
                            $controller->res()->headers()->www_authenticate('Basic');

                            $controller->render(
                                json => {
                                    error_message => 'Unauthorized : access is denied due to invalid credentials'
                                },
                                status => 401
                            );

                            return undef;
                        }
                    };

                    get '/scheduler/api' => {
                        json => {
                            version => $VERSION
                        }
                    };

                    get '/scheduler/api/general' => sub {
                        shift->render(
                            json => $scheduler->get_configuration()->get_definition()
                        );
                    };

                    put '/scheduler/api/general/webservices/(:property)' => [property => qr/(login|password)/] => sub {
                        my $controller = shift;

                        my $property = $controller->param('property');

                        my $body = eval {
                            decode_json($controller->req()->body());
                        };

                        if (ref $body eq 'HASH' && hascontent($body->{$property})) {
                            my $scheduler_definition = $scheduler->get_configuration()->get_definition();

                            $scheduler->get_configuration()->set_definition(
                                {
                                    %{$scheduler_definition},
                                    %{
                                        {
                                            webservices => {
                                                %{$scheduler_definition->{webservices}},
                                                %{
                                                    {
                                                        $property => $body->{$property}
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            )
                            ?
                                $logger->good(ucfirst($property) . ' of webservices successfully changed.', 'notice')->flush_buffer(1)
                            :
                                $logger->bad('Provided ' . $property . ' for webservices is incorrect.', 'notice')->flush_buffer(1)
                            ;
                        }

                        $controller->render(
                            json => $scheduler->get_configuration()->get_definition()
                        );
                    };

                    get '/scheduler/api/cron/jobs' => sub {
                        shift->render(
                            json => {
                                jobs_count => scalar keys %{$scheduler->get_core()->get_cron()->jobs()}
                            }
                        );
                    };

                    any [qw/GET POST/] => '/scheduler/api/connectors' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('POST') {
                                # create a resource here
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_connectors()->get_names()
                                );
                            }
                        }
                    };

                    any [qw/GET PUT DEL/] => '/scheduler/api/connectors/(:connector)' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                # modify a resource here
                            }
                            when ('DEL') {
                                # delete a resource here
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_connectors()->get_properties_by_name($controller->param('connector')) || {}
                                );
                            }
                        }
                    };

                    any [qw/GET POST/] => '/scheduler/api/rabbitmq' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('POST') {
                                # create a resource here
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_rabbitmq()->get_names()
                                );
                            }
                        }
                    };

                    any [qw/GET PUT DEL/] => '/scheduler/api/rabbitmq/(:rabbitmq)' => sub {
                        my $controller = shift;

                        given ($controller->req()->method()) {
                            when ('PUT') {
                                # modify a resource here
                            }
                            when ('DEL') {
                                # delete a resource here
                            }
                            default {
                                $controller->render(
                                    json => $scheduler->get_core()->get_rabbitmq()->get_properties_by_name($controller->param('rabbitmq')) || {}
                                );
                            }
                        }
                    };

                    get '/scheduler/api/publishers' => sub {
                        shift->render(
                            json => [map { $_->get_definition()->get_name() } @{$scheduler->get_core()->get_publishers()}]
                        );
                    };

                    get '/scheduler/api/publishers/(:publisher)' => sub {
                        my $controller = shift;

                        my $publisher = $scheduler->get_core()->get_publisher_by_definition_name($controller->param('publisher'));

                        if (defined $publisher) {
                            my $action = $controller->req()->query_params()->param('action') || '';

                            if ($action =~ /^(connect|disconnect)$/) {
                                my $method = $1;

                                my $method_generic_message = ucfirst($method) . ' publisher ' . $publisher->get_definition()->get_name();

                                if (my $error = $publisher->$method()) {
                                    $logger->bad($method_generic_message . ' : ' . $error . '.', 'notice')->flush_buffer(1);
                                } else {
                                    $logger->good($method_generic_message . '.', 'notice')->flush_buffer(1);
                                }
                            } elsif ($action eq 'clear_buffer') {
                                $logger->push_to_buffer('Clear buffer for publisher ' . $publisher->get_definition()->get_name() . '.', 'notice')->flush_buffer(1);

                                $publisher->$action();
                            }

                            $controller->render(
                                json => {
                                    connected => $publisher->get_net()->is_connected() || 0,
                                    messages_in_buffer => scalar @{$publisher->get_buffer()}
                                }
                            );
                        } else {
                            $controller->render(
                                json => {
                                    error_message => 'Publisher ' . $controller->param('publisher') . " don't exists"
                                }
                            );
                        }
                    };

                    get '/scheduler/api/webservices' => {
                        json => $web_services_listeners->get_names()
                    };

                    get '/scheduler/api/webservices/(:webservice)' => sub {
                        my $controller = shift;

                        $controller->render(
                            json => $web_services_listeners->get_properties_by_name($controller->param('webservice')) || {}
                        );
                    };

                    $prefork_server = Mojo::Server::Prefork->new(
                        app => app(),
                        listen => $web_services_listeners->get_urls()
                    );

                    # $prefork_server->workers();
                    # $prefork_server->accepts()
                    # $prefork_server->multi_accept();
                }
            }

            $logger->bad($return->[1] . '.', 'err')->flush_buffer(1) unless ($return->[0]);
        }

        if ($daemonize) {
            $logger->push_to_buffer('Daemonizing ...', 'info')->flush_buffer(1);

            Proc::Daemon->new(
                working_directory => getcwd(),
                pid_file => $pid_dir . '/navel-scheduler.pid',
                dont_close_fh => $logger->is_filehandler_via_lib() ? [
                    __PACKAGE__ . '::DATA',
                    $logger->get_filehandler()
                ] : [
                    __PACKAGE__ . '::DATA'
                ]
            )->Init();
        }

        unless ($disable_rest) {
            $logger->push_to_buffer('Starting the webservices ...', 'notice')->flush_buffer(1);

            eval {
                $prefork_server->silent(1)->start();
            };

            if ($@) {
                $logger->bad($@ . '.', 'err')->flush_buffer(1);
            } else {
                $logger->bad('Webservices successfully started.', 'notice')->flush_buffer(1);
            }
        }

        $logger->push_to_buffer('Starting the scheduler ...', 'notice')->flush_buffer(1);

        eval {
            $scheduler->run($logger);
        };

        if ($@) {
            $logger->bad($@ . '.', 'crit')->flush_buffer();

            exit 1;
        }
    } else {
        $logger->bad($@ . '.', 'crit')->flush_buffer();

        exit 1;
    }
} else {
    say get_help();

    exit 1;
}

exit 0;

#-> POD

=pod

=head1 NAME

navel-scheduler

=head1 SYNOPSIS

Control and run Navel::Scheduler

=head1 USAGE

navel-scheduler -h

=head1 AUTHOR

Yoann Le Garff, Nicolas Boquet and Yann Le Bras

=head1 LICENSE

GNU GPL v3

=cut

#-> TPL + END

__DATA__

@@ favicon.ico (base64)
AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAA
AAAAAACAgID/gICA/4CAgP+AgID/gICA/4CAgP+AgID/gICA/4CAgP+AgID/gICA/4CAgP+AgID/
gICA/4CAgP+AgID/gICA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8A
AAD/AAAA/wAAAP8AAAD/gICA/4CAgP8AAAD/////////////////////////////////////////
////////////////////////AAAA/4CAgP+AgID/AAAA////////////////////////////////
/////////////////////////////////wAAAP+AgID/gICA/wAAAP///////////wAAAP8AAAD/
AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD///////////8AAAD/gICA/4CAgP8AAAD///////////8A
AAD/////////////////////////////////AAAA////////////AAAA/4CAgP+AgID/AAAA////
////////AAAA/////////////////////////////////wAAAP///////////wAAAP+AgID/gICA
/wAAAP///////////wAAAP///////////wAAAP8AAAD///////////8AAAD///////////8AAAD/
gICA/4CAgP8AAAD///////////8AAAD///////////8AAAD/AAAA////////////AAAA////////
////AAAA/4CAgP+AgID/AAAA////////////AAAA//////8AAAD///////////8AAAD//////wAA
AP///////////wAAAP+AgID/gICA/wAAAP///////////wAAAP8AAAD/////////////////////
/wAAAP8AAAD///////////8AAAD/gICA/4CAgP8AAAD///////////8AAAD/AAAA/wAAAP8AAAD/
AAAA/wAAAP8AAAD/AAAA////////////AAAA/4CAgP+AgID/AAAA////////////////////////
//////////////////////////////8AAAD//////wAAAP+AgID/gICA/wAAAP//////////////
/////////////////////////////////////////////wAAAP8AAAD/gICA/4CAgP8AAAD/AAAA
/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/4CAgP+AgID/
gICA/4CAgP+AgID/gICA/4CAgP+AgID/gICA/4CAgP+AgID/gICA/4CAgP+AgID/gICA/4CAgP+A
gID/AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA
//8AAP//AAD//w==

@@ not_found.html.ep
<!DOCTYPE html>
<html>
    <head><title>Page not found</title></head>
    <body>Page not found</body>
</html>

@@ exception.html.ep
<!DOCTYPE html>
<html>
    <head><title>Unexcepted error</title><head>
    <body>Unexcepted error : please report bugs !</body>
</html>