#!/usr/bin/env perl
# Copyright 2015 Navel-IT
# Navel Scheduler is developed by Yoann Le Garff, Nicolas Boquet and Yann Le Bras under GNU GPL v3

#-> BEGIN

#-> initialization

use 5.10.1;

use lib '/usr/local/share/navel-scheduler/lib';

use String::Util qw/
    hascontent
/;

use Getopt::Long qw/
    Configure
    GetOptions
/;

use Proc::Daemon;

use Cwd;

use Mojolicious::Lite;

use Mojo::Server::Prefork;

use EV;

use Navel::Logger;

use Navel::Scheduler qw/
    $VERSION
/;

use Navel::Definition::WebService::Etc::Parser;

use Navel::Utils qw/
    :all
/;

#-> defaults

my (
    $general_configuration_file_path,
    $log_file_path,
    $log_severity,
    $disable_rest,
    $daemonize,
    $prefork_server
);

my $pid_dir = '/var/run';

#-> functions

sub get_help() {
    return <<EOF;

        -h, --help    show help
        -v, --version    show version

        -c, --general-configuration-file-path <F>    load general configuration from <F>

        [--log-file-path] <F>   log informations in file <F>
        [--log-severity] <F>    set severity (syslog format) to <F>

        [--no-rest]   disable the REST api

        [--daemonize]   run as a standalone daemon (only work on Unix-like systems)
EOF
}

sub ok_ko($$$) {
    my ($logger, $ok, $ko) = @_;

    $logger->good($ok, 'notice') if (defined $ok);
    $logger->bad($ko, 'notice') if (defined $ko);

    return {
        ok => $ok,
        ko => $ko
    };
}

#-> main

Configure('bundling');

GetOptions(
    'h|help' => sub {
        say get_help();

        exit 0;
    },
    'v|version' => sub {
        say $VERSION;

        exit 0;
    },
    'c|general-configuration-file-path=s' => \$general_configuration_file_path,
    'log-file-path=s' => \$log_file_path,
    'log-severity=s' => \$log_severity,
    'no-rest' => \$disable_rest,
    'daemonize' => \$daemonize

) || die $!;

if (defined $general_configuration_file_path) {
    my $logger = Navel::Logger->new(
        'notice',
        $log_file_path,
        $log_severity
    );

    my $scheduler = eval {
        Navel::Scheduler->new($general_configuration_file_path);
    };

    if ($daemonize) {
        $logger->push_to_queue('Daemonizing ...', 'info')->flush_queue(1);

        my $mojo_templates_fh = __PACKAGE__ . '::DATA';

        Proc::Daemon->new(
            working_directory => getcwd(),
            pid_file => $pid_dir . '/navel-scheduler.pid',
            dont_close_fh => $logger->is_filehandler_via_lib() ? [
                $mojo_templates_fh,
                $logger->get_filehandler()
            ] : [
                $mojo_templates_fh
            ]
        )->Init();

        IO::AIO::reinit(); # IO::AIO loaded by Navel::Scheduler
    }

    unless ($@) {
        unless ($disable_rest) {
            my $web_services_listeners = eval {
                Navel::Definition::WebService::Etc::Parser->new()->read($scheduler->get_configuration()->get_definition()->{definitions_path}->{webservices})->make();
            };

            unless ($@) {
                app()->mode('production');

                app()->log()->level('fatal');

                under sub {
                    my $controller = shift;

                    my $userinfo = $controller->req()->url()->to_abs()->userinfo();

                    if (defined $userinfo && $userinfo eq $scheduler->get_configuration()->get_definition()->{webservices}->{login} . ':' . $scheduler->get_configuration()->get_definition()->{webservices}->{password}) {
                        return 1;
                    } else {
                        $controller->res()->headers()->www_authenticate('Basic');

                        $controller->render(
                            json => ok_ko($logger, undef, 'Unauthorized : access is denied due to invalid credentials'),
                            status => 401
                        );

                        return undef;
                    }
                };

                get '/scheduler/api' => {
                    json => {
                        version => $VERSION
                    }
                };

                get '/scheduler/api/general' => sub {
                    shift->render(
                        json => $scheduler->get_configuration()->get_definition()
                    );
                };

                put '/scheduler/api/general/webservices/(:property)' => [property => qr/(login|password)/] => sub {
                    my $controller = shift;

                    my $property = $controller->param('property');

                    my $body = eval {
                        decode_json($controller->req()->body());
                    };

                    my ($ok, $ko);

                    if (hascontent($body->{$property})) {
                        my $scheduler_definition = $scheduler->get_configuration()->get_definition();

                        if ($scheduler->get_configuration()->set_definition(
                            {
                                %{$scheduler_definition},
                                %{
                                    {
                                        webservices => {
                                            %{$scheduler_definition->{webservices}},
                                            %{
                                                {
                                                    $property => $body->{$property}
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        )) {
                            $ok = ucfirst($property) . ' of webservices successfully changed.';
                        } else {
                            $ko = 'An error occurred while modifying ' . $property . ' of webservices.';
                        }
                    } else {
                        $ko = $@ || 'Property ' . $body->{$property} . ' cannot be empty';
                    }

                    $controller->render(
                        json => ok_ko($logger, $ok, $ko)
                    );
                };

                get '/scheduler/api/cron/jobs' => sub {
                    shift->render(
                        json => {
                            jobs_count => scalar keys %{$scheduler->get_core()->get_cron()->jobs()}
                        }
                    );
                };

                any [qw/GET POST/] => '/scheduler/api/connectors' => sub {
                    my $controller = shift;

                    given ($controller->req()->method()) {
                        when ('POST') {
                            my $body = eval {
                                decode_json($controller->req()->body());
                            };

                            my ($ok, $ko);

                            unless ($@) {
                                my $definition_name = eval {
                                    $scheduler->get_core()->get_connectors()->add_definition(
                                        {
                                            %{$body},
                                            %{
                                                {
                                                    exec_directory_path => $scheduler->get_configuration()->get_definition()->{definitions_path}->{connectors_exec_directory}
                                                }
                                            }
                                        }
                                    );
                                };

                                unless ($@) {
                                    $ok = 'Connector ' . $definition_name . ' successfuly added.';
                                } else {
                                    $ko = $@;
                                }
                            } else {
                                $ko = $@;
                            }

                            $controller->render(
                                json => ok_ko($logger, $ok, $ko)
                            );
                        }
                        default {
                            $controller->render(
                                json => $scheduler->get_core()->get_connectors()->get_names()
                            );
                        }
                    }
                };

                any [qw/GET PUT DEL/] => '/scheduler/api/connectors/(:connector)' => sub {
                    my $controller = shift;

                    given ($controller->req()->method()) {
                        when ('PUT') {
                            # modify a resource here
                        }
                        when ('DEL') {
                            # delete a resource here
                        }
                        default {
                            $controller->render(
                                json => $scheduler->get_core()->get_connectors()->get_properties_by_name($controller->param('connector')) || {}
                            );
                        }
                    }
                };

                any [qw/GET POST/] => '/scheduler/api/rabbitmq' => sub {
                    my $controller = shift;

                    given ($controller->req()->method()) {
                        when ('POST') {
                            # create a resource here
                        }
                        default {
                            $controller->render(
                                json => $scheduler->get_core()->get_rabbitmq()->get_names()
                            );
                        }
                    }
                };

                any [qw/GET PUT DEL/] => '/scheduler/api/rabbitmq/(:rabbitmq)' => sub {
                    my $controller = shift;

                    given ($controller->req()->method()) {
                        when ('PUT') {
                            # modify a resource here
                        }
                        when ('DEL') {
                            # delete a resource here
                        }
                        default {
                            $controller->render(
                                json => $scheduler->get_core()->get_rabbitmq()->get_properties_by_name($controller->param('rabbitmq')) || {}
                            );
                        }
                    }
                };

                get '/scheduler/api/publishers' => sub {
                    shift->render(
                        json => [map { $_->get_definition()->get_name() } @{$scheduler->get_core()->get_publishers()}]
                    );
                };

                get '/scheduler/api/publishers/(:publisher)' => sub {
                    my $controller = shift;

                    my $publisher = $scheduler->get_core()->get_publisher_by_definition_name($controller->param('publisher'));

                    if (defined $publisher) {
                        my $action = $controller->req()->query_params()->param('action') || '';

                        if ($action =~ /^(connect|disconnect)$/) {
                            my $method = $1;

                            my $method_generic_message = ucfirst($method) . ' publisher ' . $publisher->get_definition()->get_name();

                            if (my $error = $publisher->$method()) {
                                $logger->bad($method_generic_message . ' : ' . $error . '.', 'notice');
                            } else {
                                $logger->good($method_generic_message . '.', 'notice');
                            }
                        } elsif ($action eq 'clear_queue') {
                            $logger->push_to_queue('Clear queue for publisher ' . $publisher->get_definition()->get_name() . '.', 'notice');

                            $publisher->$action();
                        }

                        $controller->render(
                            json => {
                                connected => $publisher->get_net()->is_connected() || 0,
                                messages_in_queue => scalar @{$publisher->get_queue()}
                            }
                        );
                    } else {
                        $controller->render(
                            json => ok_ko($logger, undef, 'Publisher ' . $controller->param('publisher') . " don't exists")
                        );
                    }
                };

                get '/scheduler/api/webservices' => {
                    json => $web_services_listeners->get_names()
                };

                get '/scheduler/api/webservices/(:webservice)' => sub {
                    my $controller = shift;

                    $controller->render(
                        json => $web_services_listeners->get_properties_by_name($controller->param('webservice')) || {}
                    );
                };

                $prefork_server = Mojo::Server::Prefork->new(
                    app => app(),
                    listen => $web_services_listeners->get_urls()
                );

                # $prefork_server->workers();
                # $prefork_server->accepts()
                # $prefork_server->multi_accept();
            }

            $logger->bad($@ . '.', 'err')->flush_queue(1) if ($@);
        }

        unless ($disable_rest) {
            $logger->push_to_queue('Starting the webservices ...', 'notice')->flush_queue(1);

            eval {
                $prefork_server->silent(1)->start();
            };

            if ($@) {
                $logger->bad($@ . '.', 'err')->flush_queue(1);
            } else {
                $logger->good('Webservices successfully started.', 'notice')->flush_queue(1);
            }
        }

        $logger->push_to_queue('Starting the scheduler ...', 'notice')->flush_queue(1);

        eval {
            $scheduler->run($logger);
        };

        if ($@) {
            $logger->bad($@ . '.', 'crit')->flush_queue();

            exit 1;
        }
    } else {
        $logger->bad($@ . '.', 'crit')->flush_queue();

        exit 1;
    }
} else {
    say get_help();

    exit 1;
}

exit 0;

#-> POD

=pod

=head1 NAME

navel-scheduler

=head1 SYNOPSIS

Control and run Navel::Scheduler

=head1 USAGE

navel-scheduler -h

=head1 AUTHOR

Yoann Le Garff, Nicolas Boquet and Yann Le Bras

=head1 LICENSE

GNU GPL v3

=cut

#-> TPL + END

__DATA__

@@ favicon.ico (base64)
AAABAAEAEBAAAAAAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAAAAAAAAAAAAAAAAA
AAAAAAD///8B////Af///wH///8BAw4DAxY1FRUycDBDO4I4ZTuDOGUycDBDFjUVFQMOAwP///8B
////Af///wH///8B////Af///wH///8BFTIUEUCNPYVKpEfjTqxK/U+tS/9PrUv/TqxK/UukR+NA
jT2FFTEUEf///wH///8B////Af///wH///8BMGotI0mgRctPrUv/T61L/0+tS/9PrUv/UK1M/0+t
S/9PrUv/T61L/0ifRcsuZioj////Af///wH///8BIEsfDUqiRstPrEv/T61L/0+tS/+BxH7/v+C+
/9nt2f/U6tT/rtmt/2i4ZP9PrEv/SaBFyxxDGw3///8B////AUecQ31OrUv/T61L/0+tS/+Qy43/
2+3b/5XNk/9xvG3/eMB1/6vXqv/i8eL/gMN9/0+tS/9ElkF/////ATJzMAtNqUnhT61L/0+tS/9R
rk3/Va9R/1+0XP9PrUv/T61L/0+tS/9PrUv/gcR//+Dw4P9jtmD/TKZI4ypjKQ1HnUM3TqxK/0+t
S/94wHX/0enQ/2W3Yv9PrUv/T61L/0+tS/9vu2v/qtep/1GuTf+z27H/pdSj/06sSv9Bjz05TKZI
VU+sS/94wHX/4vHi/+v16//X7Nf/Y7Zg/0+tS/+b0Jn/vN+7/2i4Zf9PrUv/hcWC/8jlx/9PrUv/
R51EV02pSVVPrEv/XLNY/3G9bv/i8eL/Z7hj/1ixVP9PrUv/v+C9/1+0W/9PrUv/T61L/4DDff/M
5sv/T61L/0igRVdNqUkzT6xL/U+tS/9Rrk3/4PDg/3G8bv9PrUv/T61L/7/gvf9ftFv/T61L/0+t
S/+k1KP/r9mu/06sSv1Gm0M1TalKCU6tSt9PrUv/T61L/6LToP/F48T/VK9Q/0+tS/91vnL/VK9Q
/0+tS/9puWb/4fDg/3G9bv9NqknfQ5RACf///wFPrUt1Tq1L/0+tS/9XsFP/yOXI/8Tjw/9yvW//
UK1N/1awUv+Jx4b/3O7c/5zQmv9PrUv/TKdId////wH///8BUKxMB0+tS8VPrUv/T61L/1WwUf+k
1KL/3O7c/+fz5//n8+f/z+jO/4XGg/9PrUv/TqtKxUicRAf///8B////Af///wFQrksZT61LxU+t
S/9PrUv/T61L/1SvUP9itl//XrRb/1CtTP9PrUv/Tq1KxU2qSRn///8B////Af///wH///8B////
AVGtTAdPrkt3T61L30+tS/1PrUv/T61L/0+tS/1PrUvfT61Ld1GtTAf///8B////Af///wH///8B
////Af///wH///8B////AVCuTQlPrkszT61LVU+tS1VPrkszUK5NCf///wH///8B////Af///wH/
//8BAAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA
//8AAP//AAD//w==

@@ not_found.html.ep
<!DOCTYPE html>
<html>
    <head><title>Page not found</title></head>
    <body>Page not found</body>
</html>

@@ exception.html.ep
<!DOCTYPE html>
<html>
    <head><title>Unexcepted error</title><head>
    <body>Unexcepted error : please report bugs !</body>
</html>